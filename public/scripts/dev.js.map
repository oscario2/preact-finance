{
  "version": 3,
  "sources": ["../../node_modules/preact/src/constants.js", "../../node_modules/preact/src/util.js", "../../node_modules/preact/src/options.js", "../../node_modules/preact/src/create-element.js", "../../node_modules/preact/src/component.js", "../../node_modules/preact/src/create-context.js", "../../node_modules/preact/src/diff/children.js", "../../node_modules/preact/src/diff/props.js", "../../node_modules/preact/src/diff/index.js", "../../node_modules/preact/src/render.js", "../../node_modules/preact/src/clone-element.js", "../../node_modules/preact/src/diff/catch-error.js", "../../node_modules/preact-router/src/util.js", "../../node_modules/preact-router/src/index.js", "../../node_modules/preact/hooks/src/index.js", "../../src/utils/canvas.utils.ts", "../../src/utils/math.utils.ts", "../../src/utils/data.utils.ts", "../../src/utils/number.utils.ts", "../../src/components/MarketBox/MarketBox.types.ts", "../../src/components/MarketBox/MarketBox.utils.ts", "../../src/components/MarketBox/MarketBox.tsx", "../../node_modules/preact/compat/src/util.js", "../../node_modules/preact/compat/src/PureComponent.js", "../../node_modules/preact/compat/src/memo.js", "../../node_modules/preact/compat/src/forwardRef.js", "../../node_modules/preact/compat/src/Children.js", "../../node_modules/preact/compat/src/suspense.js", "../../node_modules/preact/compat/src/suspense-list.js", "../../node_modules/preact/compat/src/portals.js", "../../node_modules/preact/compat/src/render.js", "../../node_modules/preact/compat/src/index.js", "../../src/components/Canvas/Canvas.tsx", "../../src/components/MarketGraph/analytics/onDrawMinMax.ts", "../../src/utils/color.utils.ts", "../../src/components/MarketGraph/analytics/onDrawTrendBox.ts", "../../src/components/MarketGraph/info/onDrawCross.ts", "../../src/components/MarketGraph/info/onDrawGrid.ts", "../../src/components/MarketGraph/info/onDrawInfo.ts", "../../src/components/MarketGraph/info/onDrawPChange.ts", "../../src/components/MarketGraph/graphs/onDrawCandle.ts", "../../src/components/MarketGraph/MarketGraph.tsx", "../../src/components/OrderBook/OrderBook.utils.ts", "../../src/components/OrderBook/OrderBook.types.ts", "../../src/components/OrderBook/OrderBook.reducer.ts", "../../src/components/OrderBook/OrderBook.store.tsx", "../../src/components/OrderBook/OrderBook.actions.ts", "../../src/components/OrderBook/OrderBook.tsx", "../../src/components/OrderBook/graphs/axis/onDrawAxis.ts", "../../src/components/OrderBook/graphs/axis/AxisGraph.tsx", "../../src/components/OrderBook/graphs/depth/onDrawDepth.ts", "../../src/components/OrderBook/graphs/depth/DepthGraph.tsx", "../../src/mock/mock.utils.ts", "../../src/mock/binance-btcusdt-book.ts", "../../src/types/data.types.ts", "../../src/mock/index.ts", "../../src/utils/http.utils.ts", "../../src/api/gql.api.ts", "../../src/api/gql.utils.ts", "../../src/api/gql.query.ts", "../../src/views/MainView.tsx", "../../src/main.tsx"],
  "sourcesContent": ["export const EMPTY_OBJ = {};\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n", "import { EMPTY_ARR } from \"./constants\";\n\n/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\t// @ts-ignore We change the type of `obj` to be `O & P`\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {Node} node The node to remove\n */\nexport function removeNode(node) {\n\tlet parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n\nexport const slice = EMPTY_ARR.slice;\n", "import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n", "import { slice } from './util';\nimport options from './options';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * constructor for this virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != null) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, null);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t// _nextDom must be initialized to undefined b/c it will eventually\n\t\t// be set to dom.nextSibling which can return `null` and it is important\n\t\t// to be able to distinguish between an uninitialized _nextDom and\n\t\t// a _nextDom that has been set to `null`\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\t_hydrating: null,\n\t\tconstructor: undefined,\n\t\t_original: original == null ? ++vnodeId : original\n\t};\n\n\t// Only invoke the vnode hook if this was *not* a direct copy:\n\tif (original == null && options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is import('./internal').VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor === undefined;\n", "import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function Component(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {import('./internal').Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nComponent.prototype.setState = function(update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._vnode) {\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {import('./internal').Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nComponent.prototype.forceUpdate = function(callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {import('./index').ComponentChildren | void}\n */\nComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._parent._children.indexOf(vnode) + 1)\n\t\t\t: null;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != null && sibling._dom != null) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet vnode = component._vnode,\n\t\toldDom = vnode._dom,\n\t\tparentDom = component._parentDom;\n\n\tif (parentDom) {\n\t\tlet commitQueue = [];\n\t\tconst oldVNode = assign({}, vnode);\n\t\toldVNode._original = vnode._original + 1;\n\n\t\tdiff(\n\t\t\tparentDom,\n\t\t\tvnode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tparentDom.ownerSVGElement !== undefined,\n\t\t\tvnode._hydrating != null ? [oldDom] : null,\n\t\t\tcommitQueue,\n\t\t\toldDom == null ? getDomSibling(vnode) : oldDom,\n\t\t\tvnode._hydrating\n\t\t);\n\t\tcommitRoot(commitQueue, vnode);\n\n\t\tif (vnode._dom != oldDom) {\n\t\t\tupdateParentDomPointers(vnode);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != null && vnode._component != null) {\n\t\tvnode._dom = vnode._component.base = null;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != null && child._dom != null) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/**\n * Asynchronously schedule a callback\n * @type {(cb: () => void) => void}\n */\n/* istanbul ignore next */\n// Note the following line isn't tree-shaken by rollup cuz of rollup/rollup#2566\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet queue;\n\twhile ((process._rerenderCount = rerenderQueue.length)) {\n\t\tqueue = rerenderQueue.sort((a, b) => a._vnode._depth - b._vnode._depth);\n\t\trerenderQueue = [];\n\t\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t\t// process() calls from getting scheduled while `queue` is still being consumed.\n\t\tqueue.some(c => {\n\t\t\tif (c._dirty) renderComponent(c);\n\t\t});\n\t}\n}\nprocess._rerenderCount = 0;\n", "import { enqueueRender } from './component';\n\nexport let i = 0;\n\nexport function createContext(defaultValue, contextId) {\n\tcontextId = '__cC' + i++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\t/** @type {import('./internal').FunctionComponent} */\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\t/** @type {import('./internal').FunctionComponent} */\n\t\tProvider(props) {\n\t\t\tif (!this.getChildContext) {\n\t\t\t\tlet subs = [];\n\t\t\t\tlet ctx = {};\n\t\t\t\tctx[contextId] = this;\n\n\t\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\t\tthis.shouldComponentUpdate = function(_props) {\n\t\t\t\t\tif (this.props.value !== _props.value) {\n\t\t\t\t\t\t// I think the forced value propagation here was only needed when `options.debounceRendering` was being bypassed:\n\t\t\t\t\t\t// https://github.com/preactjs/preact/commit/4d339fb803bea09e9f198abf38ca1bf8ea4b7771#diff-54682ce380935a717e41b8bfc54737f6R358\n\t\t\t\t\t\t// In those cases though, even with the value corrected, we're double-rendering all nodes.\n\t\t\t\t\t\t// It might be better to just tell folks not to use force-sync mode.\n\t\t\t\t\t\t// Currently, using `useContext()` in a class component will overwrite its `this.context` value.\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context[contextId] = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\t\t\t\t\t\tsubs.some(enqueueRender);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.sub = c => {\n\t\t\t\t\tsubs.push(c);\n\t\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\t\tsubs.splice(subs.indexOf(c), 1);\n\t\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType = context);\n}\n", "import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { getDomSibling } from '../component';\n\n/**\n * Diff the children of a virtual node\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\n * children are being diffed\n * @param {import('../internal').ComponentChildren[]} renderResult\n * @param {import('../internal').VNode} newParentVNode The new virtual\n * node whose children should be diff'ed against oldParentVNode\n * @param {import('../internal').VNode} oldParentVNode The old virtual\n * node whose children should be diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by getChildContext\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').PreactElement} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet i, j, oldVNode, childVNode, newDom, firstChildDom, refs;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet oldChildrenLength = oldChildren.length;\n\n\tnewParentVNode._children = [];\n\tfor (i = 0; i < renderResult.length; i++) {\n\t\tchildVNode = renderResult[i];\n\n\t\tif (childVNode == null || typeof childVNode == 'boolean') {\n\t\t\tchildVNode = newParentVNode._children[i] = null;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (\n\t\t\ttypeof childVNode == 'string' ||\n\t\t\ttypeof childVNode == 'number' ||\n\t\t\t// eslint-disable-next-line valid-typeof\n\t\t\ttypeof childVNode == 'bigint'\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tnull,\n\t\t\t\tchildVNode,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t} else if (Array.isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (childVNode._depth > 0) {\n\t\t\t// VNode is already in use, clone it. This can happen in the following\n\t\t\t// scenario:\n\t\t\t//   const reuse = <div />\n\t\t\t//   <div>{reuse}<span />{reuse}</div>\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tnull,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Check if we find a corresponding element in oldChildren.\n\t\t// If found, delete the array item by setting to `undefined`.\n\t\t// We use `undefined`, as `null` is reserved for empty placeholders\n\t\t// (holes).\n\t\toldVNode = oldChildren[i];\n\n\t\tif (\n\t\t\toldVNode === null ||\n\t\t\t(oldVNode &&\n\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\tchildVNode.type === oldVNode.type)\n\t\t) {\n\t\t\toldChildren[i] = undefined;\n\t\t} else {\n\t\t\t// Either oldVNode === undefined or oldChildrenLength > 0,\n\t\t\t// so after this loop oldVNode == null or oldVNode is a valid value.\n\t\t\tfor (j = 0; j < oldChildrenLength; j++) {\n\t\t\t\toldVNode = oldChildren[j];\n\t\t\t\t// If childVNode is unkeyed, we only match similarly unkeyed nodes, otherwise we match by key.\n\t\t\t\t// We always match by type (in either case).\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\t\tchildVNode.type === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\toldChildren[j] = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toldVNode = null;\n\t\t\t}\n\t\t}\n\n\t\toldVNode = oldVNode || EMPTY_OBJ;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tdiff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tisSvg,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating\n\t\t);\n\n\t\tnewDom = childVNode._dom;\n\n\t\tif ((j = childVNode.ref) && oldVNode.ref != j) {\n\t\t\tif (!refs) refs = [];\n\t\t\tif (oldVNode.ref) refs.push(oldVNode.ref, null, childVNode);\n\t\t\trefs.push(j, childVNode._component || newDom, childVNode);\n\t\t}\n\n\t\tif (newDom != null) {\n\t\t\tif (firstChildDom == null) {\n\t\t\t\tfirstChildDom = newDom;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttypeof childVNode.type == 'function' &&\n\t\t\t\tchildVNode._children === oldVNode._children\n\t\t\t) {\n\t\t\t\tchildVNode._nextDom = oldDom = reorderChildren(\n\t\t\t\t\tchildVNode,\n\t\t\t\t\toldDom,\n\t\t\t\t\tparentDom\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\toldDom = placeChild(\n\t\t\t\t\tparentDom,\n\t\t\t\t\tchildVNode,\n\t\t\t\t\toldVNode,\n\t\t\t\t\toldChildren,\n\t\t\t\t\tnewDom,\n\t\t\t\t\toldDom\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (typeof newParentVNode.type == 'function') {\n\t\t\t\t// Because the newParentVNode is Fragment-like, we need to set it's\n\t\t\t\t// _nextDom property to the nextSibling of its last child DOM node.\n\t\t\t\t//\n\t\t\t\t// `oldDom` contains the correct value here because if the last child\n\t\t\t\t// is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n\t\t\t\t// If the last child is a DOM VNode, then oldDom will be set to that DOM\n\t\t\t\t// node's nextSibling.\n\t\t\t\tnewParentVNode._nextDom = oldDom;\n\t\t\t}\n\t\t} else if (\n\t\t\toldDom &&\n\t\t\toldVNode._dom == oldDom &&\n\t\t\toldDom.parentNode != parentDom\n\t\t) {\n\t\t\t// The above condition is to handle null placeholders. See test in placeholder.test.js:\n\t\t\t// `efficiently replace null placeholders in parent rerenders`\n\t\t\toldDom = getDomSibling(oldVNode);\n\t\t}\n\t}\n\n\tnewParentVNode._dom = firstChildDom;\n\n\t// Remove remaining oldChildren if there are any.\n\tfor (i = oldChildrenLength; i--; ) {\n\t\tif (oldChildren[i] != null) {\n\t\t\tif (\n\t\t\t\ttypeof newParentVNode.type == 'function' &&\n\t\t\t\toldChildren[i]._dom != null &&\n\t\t\t\toldChildren[i]._dom == newParentVNode._nextDom\n\t\t\t) {\n\t\t\t\t// If the newParentVNode.__nextDom points to a dom node that is about to\n\t\t\t\t// be unmounted, then get the next sibling of that vnode and set\n\t\t\t\t// _nextDom to it\n\t\t\t\tnewParentVNode._nextDom = getDomSibling(oldParentVNode, i + 1);\n\t\t\t}\n\n\t\t\tunmount(oldChildren[i], oldChildren[i]);\n\t\t}\n\t}\n\n\t// Set refs only after unmount\n\tif (refs) {\n\t\tfor (i = 0; i < refs.length; i++) {\n\t\t\tapplyRef(refs[i], refs[++i], refs[++i]);\n\t\t}\n\t}\n}\n\nfunction reorderChildren(childVNode, oldDom, parentDom) {\n\t// Note: VNodes in nested suspended trees may be missing _children.\n\tlet c = childVNode._children;\n\tlet tmp = 0;\n\tfor (; c && tmp < c.length; tmp++) {\n\t\tlet vnode = c[tmp];\n\t\tif (vnode) {\n\t\t\t// We typically enter this code path on sCU bailout, where we copy\n\t\t\t// oldVNode._children to newVNode._children. If that is the case, we need\n\t\t\t// to update the old children's _parent pointer to point to the newVNode\n\t\t\t// (childVNode here).\n\t\t\tvnode._parent = childVNode;\n\n\t\t\tif (typeof vnode.type == 'function') {\n\t\t\t\toldDom = reorderChildren(vnode, oldDom, parentDom);\n\t\t\t} else {\n\t\t\t\toldDom = placeChild(\n\t\t\t\t\tparentDom,\n\t\t\t\t\tvnode,\n\t\t\t\t\tvnode,\n\t\t\t\t\tc,\n\t\t\t\t\tvnode._dom,\n\t\t\t\t\toldDom\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn oldDom;\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {import('../index').ComponentChildren} children The unflattened\n * children of a virtual node\n * @returns {import('../internal').VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (Array.isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\nfunction placeChild(\n\tparentDom,\n\tchildVNode,\n\toldVNode,\n\toldChildren,\n\tnewDom,\n\toldDom\n) {\n\tlet nextDom;\n\tif (childVNode._nextDom !== undefined) {\n\t\t// Only Fragments or components that return Fragment like VNodes will\n\t\t// have a non-undefined _nextDom. Continue the diff from the sibling\n\t\t// of last DOM child of this child VNode\n\t\tnextDom = childVNode._nextDom;\n\n\t\t// Eagerly cleanup _nextDom. We don't need to persist the value because\n\t\t// it is only used by `diffChildren` to determine where to resume the diff after\n\t\t// diffing Components and Fragments. Once we store it the nextDOM local var, we\n\t\t// can clean up the property\n\t\tchildVNode._nextDom = undefined;\n\t} else if (\n\t\toldVNode == null ||\n\t\tnewDom != oldDom ||\n\t\tnewDom.parentNode == null\n\t) {\n\t\touter: if (oldDom == null || oldDom.parentNode !== parentDom) {\n\t\t\tparentDom.appendChild(newDom);\n\t\t\tnextDom = null;\n\t\t} else {\n\t\t\t// `j<oldChildrenLength; j+=2` is an alternative to `j++<oldChildrenLength/2`\n\t\t\tfor (\n\t\t\t\tlet sibDom = oldDom, j = 0;\n\t\t\t\t(sibDom = sibDom.nextSibling) && j < oldChildren.length;\n\t\t\t\tj += 2\n\t\t\t) {\n\t\t\t\tif (sibDom == newDom) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparentDom.insertBefore(newDom, oldDom);\n\t\t\tnextDom = oldDom;\n\t\t}\n\t}\n\n\t// If we have pre-calculated the nextDOM node, use it. Else calculate it now\n\t// Strictly check for `undefined` here cuz `null` is a valid value of `nextDom`.\n\t// See more detail in create-element.js:createVNode\n\tif (nextDom !== undefined) {\n\t\toldDom = nextDom;\n\t} else {\n\t\toldDom = newDom.nextSibling;\n\t}\n\n\treturn oldDom;\n}\n", "import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\n/**\n * Diff the old and new properties of a VNode and apply changes to the DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to apply\n * changes to\n * @param {object} newProps The new props\n * @param {object} oldProps The old props\n * @param {boolean} isSvg Whether or not this node is an SVG node\n * @param {boolean} hydrate Whether or not we are in hydration mode\n */\nexport function diffProps(dom, newProps, oldProps, isSvg, hydrate) {\n\tlet i;\n\n\tfor (i in oldProps) {\n\t\tif (i !== 'children' && i !== 'key' && !(i in newProps)) {\n\t\t\tsetProperty(dom, i, null, oldProps[i], isSvg);\n\t\t}\n\t}\n\n\tfor (i in newProps) {\n\t\tif (\n\t\t\t(!hydrate || typeof newProps[i] == 'function') &&\n\t\t\ti !== 'children' &&\n\t\t\ti !== 'key' &&\n\t\t\ti !== 'value' &&\n\t\t\ti !== 'checked' &&\n\t\t\toldProps[i] !== newProps[i]\n\t\t) {\n\t\t\tsetProperty(dom, i, newProps[i], oldProps[i], isSvg);\n\t\t}\n\t}\n}\n\nfunction setStyle(style, key, value) {\n\tif (key[0] === '-') {\n\t\tstyle.setProperty(key, value);\n\t} else if (value == null) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, isSvg) {\n\tlet useCapture;\n\n\to: if (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture = name !== (name = name.replace(/Capture$/, ''));\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (name.toLowerCase() in dom) name = name.toLowerCase().slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tconst handler = useCapture ? eventProxyCapture : eventProxy;\n\t\t\t\tdom.addEventListener(name, handler, useCapture);\n\t\t\t}\n\t\t} else {\n\t\t\tconst handler = useCapture ? eventProxyCapture : eventProxy;\n\t\t\tdom.removeEventListener(name, handler, useCapture);\n\t\t}\n\t} else if (name !== 'dangerouslySetInnerHTML') {\n\t\tif (isSvg) {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink[H:h]/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname !== 'href' &&\n\t\t\tname !== 'list' &&\n\t\t\tname !== 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname !== 'tabIndex' &&\n\t\t\tname !== 'download' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == null ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// ARIA-attributes have a different notion of boolean values.\n\t\t// The value `false` is different from the attribute not\n\t\t// existing on the DOM, so we can't remove it. For non-boolean\n\t\t// ARIA-attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost us too many bytes. On top of\n\t\t// that other VDOM frameworks also always stringify `false`.\n\n\t\tif (typeof value === 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (\n\t\t\tvalue != null &&\n\t\t\t(value !== false || (name[0] === 'a' && name[1] === 'r'))\n\t\t) {\n\t\t\tdom.setAttribute(name, value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Proxy an event to hooked event handlers\n * @param {Event} e The event object from the browser\n * @private\n */\nfunction eventProxy(e) {\n\tthis._listeners[e.type + false](options.event ? options.event(e) : e);\n}\n\nfunction eventProxyCapture(e) {\n\tthis._listeners[e.type + true](options.event ? options.event(e) : e);\n}\n", "import { EMPTY_OBJ } from '../constants';\nimport { Component, getDomSibling } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren } from './children';\nimport { diffProps, setProperty } from './props';\nimport { assign, removeNode, slice } from '../util';\nimport options from '../options';\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by getChildContext\n * @param {boolean} isSvg Whether or not this element is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').PreactElement} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} [isHydrating] Whether or not we are in hydration\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== undefined) return null;\n\n\t// If the previous diff bailed out, resume creating/hydrating.\n\tif (oldVNode._hydrating != null) {\n\t\tisHydrating = oldVNode._hydrating;\n\t\toldDom = newVNode._dom = oldVNode._dom;\n\t\t// if we resume, we want the tree to be \"unlocked\"\n\t\tnewVNode._hydrating = null;\n\t\texcessDomChildren = [oldDom];\n\t}\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\ttry {\n\t\touter: if (typeof newType == 'function') {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif ('prototype' in newType && newType.prototype.render) {\n\t\t\t\t\t// @ts-ignore The check above verifies that newType is suppose to be constructed\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-ignore Trust me, Component implements the interface we want\n\t\t\t\t\tnewVNode._component = c = new Component(newProps, componentContext);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (c._nextState == null) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\t\t\tif (newType.getDerivedStateFromProps != null) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tc.componentWillMount != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidMount != null) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(!c._force &&\n\t\t\t\t\t\tc.shouldComponentUpdate != null &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\tnewVNode._original === oldVNode._original\n\t\t\t\t) {\n\t\t\t\t\tc.props = newProps;\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original !== oldVNode._original) c._dirty = false;\n\t\t\t\t\tc._vnode = newVNode;\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tnewVNode._children.forEach(vnode => {\n\t\t\t\t\t\tif (vnode) vnode._parent = newVNode;\n\t\t\t\t\t});\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != null) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidUpdate != null) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc.state = c._nextState;\n\n\t\t\tif ((tmp = options._render)) tmp(newVNode);\n\n\t\t\tc._dirty = false;\n\t\t\tc._vnode = newVNode;\n\t\t\tc._parentDom = parentDom;\n\n\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != null) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (!isNew && c.getSnapshotBeforeUpdate != null) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != null && tmp.type === Fragment && tmp.key == null;\n\t\t\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n\n\t\t\tdiffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\t\tnewVNode._hydrating = null;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = null;\n\t\t\t}\n\n\t\t\tc._force = false;\n\t\t} else if (\n\t\t\texcessDomChildren == null &&\n\t\t\tnewVNode._original === oldVNode._original\n\t\t) {\n\t\t\tnewVNode._children = oldVNode._children;\n\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t} else {\n\t\t\tnewVNode._dom = diffElementNodes(\n\t\t\t\toldVNode._dom,\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\tif ((tmp = options.diffed)) tmp(newVNode);\n\t} catch (e) {\n\t\tnewVNode._original = null;\n\t\t// if hydrating or creating initial tree, bailout preserves DOM:\n\t\tif (isHydrating || excessDomChildren != null) {\n\t\t\tnewVNode._dom = oldDom;\n\t\t\tnewVNode._hydrating = !!isHydrating;\n\t\t\texcessDomChildren[excessDomChildren.indexOf(oldDom)] = null;\n\t\t\t// ^ could possibly be simplified to:\n\t\t\t// excessDomChildren.length = 0;\n\t\t}\n\t\toptions._catchError(e, newVNode, oldVNode);\n\t}\n}\n\n/**\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').VNode} root\n */\nexport function commitRoot(commitQueue, root) {\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\t// @ts-ignore Reuse the commitQueue variable here so the type changes\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\t// @ts-ignore See above ts-ignore on commitQueue\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {import('../internal').PreactElement} dom The DOM element representing\n * the virtual nodes being diffed\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {*} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @returns {import('../internal').PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating\n) {\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\tlet nodeType = newVNode.type;\n\tlet i = 0;\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tif (nodeType === 'svg') isSvg = true;\n\n\tif (excessDomChildren != null) {\n\t\tfor (; i < excessDomChildren.length; i++) {\n\t\t\tconst child = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tchild &&\n\t\t\t\t(child === dom ||\n\t\t\t\t\t(nodeType ? child.localName == nodeType : child.nodeType == 3))\n\t\t\t) {\n\t\t\t\tdom = child;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == null) {\n\t\tif (nodeType === null) {\n\t\t\t// @ts-ignore createTextNode returns Text, we expect PreactElement\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tif (isSvg) {\n\t\t\tdom = document.createElementNS(\n\t\t\t\t'http://www.w3.org/2000/svg',\n\t\t\t\t// @ts-ignore We know `newVNode.type` is a string\n\t\t\t\tnodeType\n\t\t\t);\n\t\t} else {\n\t\t\tdom = document.createElement(\n\t\t\t\t// @ts-ignore We know `newVNode.type` is a string\n\t\t\t\tnodeType,\n\t\t\t\tnewProps.is && newProps\n\t\t\t);\n\t\t}\n\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t\t// we are creating a new node, so we can assume this is a new subtree (in case we are hydrating), this deopts the hydrate\n\t\tisHydrating = false;\n\t}\n\n\tif (nodeType === null) {\n\t\t// During hydration, we still have to split merged text from SSR'd HTML.\n\t\tif (oldProps !== newProps && (!isHydrating || dom.data !== newProps)) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\t// If excessDomChildren was not null, repopulate it with the current element's children:\n\t\texcessDomChildren = excessDomChildren && slice.call(dom.childNodes);\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\tlet oldHtml = oldProps.dangerouslySetInnerHTML;\n\t\tlet newHtml = newProps.dangerouslySetInnerHTML;\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tif (!isHydrating) {\n\t\t\t// But, if we are in a situation where we are using existing DOM (e.g. replaceNode)\n\t\t\t// we should read the existing DOM attributes to diff them\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\toldProps = {};\n\t\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\t\toldProps[dom.attributes[i].name] = dom.attributes[i].value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (newHtml || oldHtml) {\n\t\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\t\tif (\n\t\t\t\t\t!newHtml ||\n\t\t\t\t\t((!oldHtml || newHtml.__html != oldHtml.__html) &&\n\t\t\t\t\t\tnewHtml.__html !== dom.innerHTML)\n\t\t\t\t) {\n\t\t\t\t\tdom.innerHTML = (newHtml && newHtml.__html) || '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdiffProps(dom, newProps, oldProps, isSvg, isHydrating);\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\ti = newVNode.props.children;\n\t\t\tdiffChildren(\n\t\t\t\tdom,\n\t\t\t\tArray.isArray(i) ? i : [i],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg && nodeType !== 'foreignObject',\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\texcessDomChildren\n\t\t\t\t\t? excessDomChildren[0]\n\t\t\t\t\t: oldVNode._children && getDomSibling(oldVNode, 0),\n\t\t\t\tisHydrating\n\t\t\t);\n\n\t\t\t// Remove children that are not part of any vnode.\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\t\t\tif (excessDomChildren[i] != null) removeNode(excessDomChildren[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// (as above, don't diff props during hydration)\n\t\tif (!isHydrating) {\n\t\t\tif (\n\t\t\t\t'value' in newProps &&\n\t\t\t\t(i = newProps.value) !== undefined &&\n\t\t\t\t// #2756 For the <progress>-element the initial value is 0,\n\t\t\t\t// despite the attribute not being present. When the attribute\n\t\t\t\t// is missing the progress bar is treated as indeterminate.\n\t\t\t\t// To fix that we'll always update it when it is 0 for progress elements\n\t\t\t\t(i !== dom.value || (nodeType === 'progress' && !i))\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'value', i, oldProps.value, false);\n\t\t\t}\n\t\t\tif (\n\t\t\t\t'checked' in newProps &&\n\t\t\t\t(i = newProps.checked) !== undefined &&\n\t\t\t\ti !== dom.checked\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'checked', i, oldProps.checked, false);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {object|function} ref\n * @param {any} value\n * @param {import('../internal').VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {import('../internal').VNode} vnode The virtual node to unmount\n * @param {import('../internal').VNode} parentVNode The parent of the VNode that\n * initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current === vnode._dom) applyRef(r, null, parentVNode);\n\t}\n\n\tif ((r = vnode._component) != null) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = null;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(r[i], parentVNode, typeof vnode.type != 'function');\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove && vnode._dom != null) removeNode(vnode._dom);\n\n\t// Must be set to `undefined` to properly clean up `_nextDom`\n\t// for which `null` is a valid value. See comment in `create-element.js`\n\tvnode._dom = vnode._nextDom = undefined;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n", "import { EMPTY_OBJ } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { slice } from './util';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * render into\n * @param {import('./internal').PreactElement | object} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we are in\n\t// hydration mode or not by passing the `hydrate` function instead of a DOM\n\t// element..\n\tlet isHydrating = typeof replaceNode === 'function';\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? null\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\n\tvnode = (\n\t\t(!isHydrating && replaceNode) ||\n\t\tparentDom\n\t)._children = createElement(Fragment, null, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\tvnode,\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.ownerSVGElement !== undefined,\n\t\t!isHydrating && replaceNode\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t? null\n\t\t\t: parentDom.firstChild\n\t\t\t? slice.call(parentDom.childNodes)\n\t\t\t: null,\n\t\tcommitQueue,\n\t\t!isHydrating && replaceNode\n\t\t\t? replaceNode\n\t\t\t: oldVNode\n\t\t\t? oldVNode._dom\n\t\t\t: parentDom.firstChild,\n\t\tisHydrating\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, hydrate);\n}\n", "import { assign, slice } from './util';\nimport { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Any additional arguments will be used as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tnull\n\t);\n}\n", "/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').VNode} vnode The vnode that threw\n * the error that was caught (except for unmounting when this parameter\n * is the highest parent that was being unmounted)\n */\nexport function _catchError(error, vnode) {\n\t/** @type {import('../internal').Component} */\n\tlet component, ctor, handled;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tctor = component.constructor;\n\n\t\t\t\tif (ctor && ctor.getDerivedStateFromError != null) {\n\t\t\t\t\tcomponent.setState(ctor.getDerivedStateFromError(error));\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != null) {\n\t\t\t\t\tcomponent.componentDidCatch(error);\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\t// This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\n\t\t\t\tif (handled) {\n\t\t\t\t\treturn (component._pendingError = component);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n", "\nconst EMPTY = {};\n\nexport function assign(obj, props) {\n\t// eslint-disable-next-line guard-for-in\n\tfor (let i in props) {\n\t\tobj[i] = props[i];\n\t}\n\treturn obj;\n}\n\nexport function exec(url, route, opts) {\n\tlet reg = /(?:\\?([^#]*))?(#.*)?$/,\n\t\tc = url.match(reg),\n\t\tmatches = {},\n\t\tret;\n\tif (c && c[1]) {\n\t\tlet p = c[1].split('&');\n\t\tfor (let i=0; i<p.length; i++) {\n\t\t\tlet r = p[i].split('=');\n\t\t\tmatches[decodeURIComponent(r[0])] = decodeURIComponent(r.slice(1).join('='));\n\t\t}\n\t}\n\turl = segmentize(url.replace(reg, ''));\n\troute = segmentize(route || '');\n\tlet max = Math.max(url.length, route.length);\n\tfor (let i=0; i<max; i++) {\n\t\tif (route[i] && route[i].charAt(0)===':') {\n\t\t\tlet param = route[i].replace(/(^:|[+*?]+$)/g, ''),\n\t\t\t\tflags = (route[i].match(/[+*?]+$/) || EMPTY)[0] || '',\n\t\t\t\tplus = ~flags.indexOf('+'),\n\t\t\t\tstar = ~flags.indexOf('*'),\n\t\t\t\tval = url[i] || '';\n\t\t\tif (!val && !star && (flags.indexOf('?')<0 || plus)) {\n\t\t\t\tret = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatches[param] = decodeURIComponent(val);\n\t\t\tif (plus || star) {\n\t\t\t\tmatches[param] = url.slice(i).map(decodeURIComponent).join('/');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (route[i]!==url[i]) {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (opts.default!==true && ret===false) return false;\n\treturn matches;\n}\n\nexport function pathRankSort(a, b) {\n\treturn (\n\t\t(a.rank < b.rank) ? 1 :\n\t\t\t(a.rank > b.rank) ? -1 :\n\t\t\t\t(a.index - b.index)\n\t);\n}\n\n// filter out VNodes without attributes (which are unrankeable), and add `index`/`rank` properties to be used in sorting.\nexport function prepareVNodeForRanking(vnode, index) {\n\tvnode.index = index;\n\tvnode.rank = rankChild(vnode);\n\treturn vnode.props;\n}\n\nexport function segmentize(url) {\n\treturn url.replace(/(^\\/+|\\/+$)/g, '').split('/');\n}\n\nexport function rankSegment(segment) {\n\treturn segment.charAt(0)==':' ? (1 + '*+?'.indexOf(segment.charAt(segment.length-1))) || 4 : 5;\n}\n\nexport function rank(path) {\n\treturn segmentize(path).map(rankSegment).join('');\n}\n\nfunction rankChild(vnode) {\n\treturn vnode.props.default ? 0 : rank(vnode.props.path);\n}\n", "import { cloneElement, createElement, Component, toChildArray } from 'preact';\nimport { exec, prepareVNodeForRanking, assign, pathRankSort } from './util';\n\nlet customHistory = null;\n\nconst ROUTERS = [];\n\nconst subscribers = [];\n\nconst EMPTY = {};\n\nfunction setUrl(url, type='push') {\n\tif (customHistory && customHistory[type]) {\n\t\tcustomHistory[type](url);\n\t}\n\telse if (typeof history!=='undefined' && history[type+'State']) {\n\t\thistory[type+'State'](null, null, url);\n\t}\n}\n\n\nfunction getCurrentUrl() {\n\tlet url;\n\tif (customHistory && customHistory.location) {\n\t\turl = customHistory.location;\n\t}\n\telse if (customHistory && customHistory.getCurrentLocation) {\n\t\turl = customHistory.getCurrentLocation();\n\t}\n\telse {\n\t\turl = typeof location!=='undefined' ? location : EMPTY;\n\t}\n\treturn `${url.pathname || ''}${url.search || ''}`;\n}\n\n\n\nfunction route(url, replace=false) {\n\tif (typeof url!=='string' && url.url) {\n\t\treplace = url.replace;\n\t\turl = url.url;\n\t}\n\n\t// only push URL into history if we can handle it\n\tif (canRoute(url)) {\n\t\tsetUrl(url, replace ? 'replace' : 'push');\n\t}\n\n\treturn routeTo(url);\n}\n\n\n/** Check if the given URL can be handled by any router instances. */\nfunction canRoute(url) {\n\tfor (let i=ROUTERS.length; i--; ) {\n\t\tif (ROUTERS[i].canRoute(url)) return true;\n\t}\n\treturn false;\n}\n\n\n/** Tell all router instances to handle the given URL.  */\nfunction routeTo(url) {\n\tlet didRoute = false;\n\tfor (let i=0; i<ROUTERS.length; i++) {\n\t\tif (ROUTERS[i].routeTo(url)===true) {\n\t\t\tdidRoute = true;\n\t\t}\n\t}\n\tfor (let i=subscribers.length; i--; ) {\n\t\tsubscribers[i](url);\n\t}\n\treturn didRoute;\n}\n\n\nfunction routeFromLink(node) {\n\t// only valid elements\n\tif (!node || !node.getAttribute) return;\n\n\tlet href = node.getAttribute('href'),\n\t\ttarget = node.getAttribute('target');\n\n\t// ignore links with targets and non-path URLs\n\tif (!href || !href.match(/^\\//g) || (target && !target.match(/^_?self$/i))) return;\n\n\t// attempt to route, if no match simply cede control to browser\n\treturn route(href);\n}\n\n\nfunction handleLinkClick(e) {\n\tif (e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || e.button!==0) return;\n\trouteFromLink(e.currentTarget || e.target || this);\n\treturn prevent(e);\n}\n\n\nfunction prevent(e) {\n\tif (e) {\n\t\tif (e.stopImmediatePropagation) e.stopImmediatePropagation();\n\t\tif (e.stopPropagation) e.stopPropagation();\n\t\te.preventDefault();\n\t}\n\treturn false;\n}\n\n\nfunction delegateLinkHandler(e) {\n\t// ignore events the browser takes care of already:\n\tif (e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || e.button!==0) return;\n\n\tlet t = e.target;\n\tdo {\n\t\tif (String(t.nodeName).toUpperCase()==='A' && t.getAttribute('href')) {\n\t\t\tif (t.hasAttribute('native')) return;\n\t\t\t// if link is handled by the router, prevent browser defaults\n\t\t\tif (routeFromLink(t)) {\n\t\t\t\treturn prevent(e);\n\t\t\t}\n\t\t}\n\t} while ((t=t.parentNode));\n}\n\n\nlet eventListenersInitialized = false;\n\nfunction initEventListeners() {\n\tif (eventListenersInitialized) return;\n\n\tif (typeof addEventListener==='function') {\n\t\tif (!customHistory) {\n\t\t\taddEventListener('popstate', () => {\n\t\t\t\trouteTo(getCurrentUrl());\n\t\t\t});\n\t\t}\n\t\taddEventListener('click', delegateLinkHandler);\n\t}\n\teventListenersInitialized = true;\n}\n\n\nclass Router extends Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tif (props.history) {\n\t\t\tcustomHistory = props.history;\n\t\t}\n\n\t\tthis.state = {\n\t\t\turl: props.url || getCurrentUrl()\n\t\t};\n\n\t\tinitEventListeners();\n\t}\n\n\tshouldComponentUpdate(props) {\n\t\tif (props.static!==true) return true;\n\t\treturn props.url!==this.props.url || props.onChange!==this.props.onChange;\n\t}\n\n\t/** Check if the given URL can be matched against any children */\n\tcanRoute(url) {\n\t\tconst children = toChildArray(this.props.children);\n\t\treturn this.getMatchingChildren(children, url, false).length > 0;\n\t}\n\n\t/** Re-render children with a new URL to match against. */\n\trouteTo(url) {\n\t\tthis.setState({ url });\n\n\t\tconst didRoute = this.canRoute(url);\n\n\t\t// trigger a manual re-route if we're not in the middle of an update:\n\t\tif (!this.updating) this.forceUpdate();\n\n\t\treturn didRoute;\n\t}\n\n\tcomponentWillMount() {\n\t\tROUTERS.push(this);\n\t\tthis.updating = true;\n\t}\n\n\tcomponentDidMount() {\n\t\tif (customHistory) {\n\t\t\tthis.unlisten = customHistory.listen((location) => {\n\t\t\t\tthis.routeTo(`${location.pathname || ''}${location.search || ''}`);\n\t\t\t});\n\t\t}\n\t\tthis.updating = false;\n\t}\n\n\tcomponentWillUnmount() {\n\t\tif (typeof this.unlisten==='function') this.unlisten();\n\t\tROUTERS.splice(ROUTERS.indexOf(this), 1);\n\t}\n\n\tcomponentWillUpdate() {\n\t\tthis.updating = true;\n\t}\n\n\tcomponentDidUpdate() {\n\t\tthis.updating = false;\n\t}\n\n\tgetMatchingChildren(children, url, invoke) {\n\t\treturn children\n\t\t\t.filter(prepareVNodeForRanking)\n\t\t\t.sort(pathRankSort)\n\t\t\t.map( vnode => {\n\t\t\t\tlet matches = exec(url, vnode.props.path, vnode.props);\n\t\t\t\tif (matches) {\n\t\t\t\t\tif (invoke !== false) {\n\t\t\t\t\t\tlet newProps = { url, matches };\n\t\t\t\t\t\tassign(newProps, matches);\n\t\t\t\t\t\tdelete newProps.ref;\n\t\t\t\t\t\tdelete newProps.key;\n\t\t\t\t\t\treturn cloneElement(vnode, newProps);\n\t\t\t\t\t}\n\t\t\t\t\treturn vnode;\n\t\t\t\t}\n\t\t\t}).filter(Boolean);\n\t}\n\n\trender({ children, onChange }, { url }) {\n\t\tlet active = this.getMatchingChildren(toChildArray(children), url, true);\n\n\t\tlet current = active[0] || null;\n\n\t\tlet previous = this.previousUrl;\n\t\tif (url!==previous) {\n\t\t\tthis.previousUrl = url;\n\t\t\tif (typeof onChange==='function') {\n\t\t\t\tonChange({\n\t\t\t\t\trouter: this,\n\t\t\t\t\turl,\n\t\t\t\t\tprevious,\n\t\t\t\t\tactive,\n\t\t\t\t\tcurrent\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn current;\n\t}\n}\n\nconst Link = (props) => (\n\tcreateElement('a', assign({ onClick: handleLinkClick }, props))\n);\n\nconst Route = props => createElement(props.component, props);\n\nRouter.subscribers = subscribers;\nRouter.getCurrentUrl = getCurrentUrl;\nRouter.route = route;\nRouter.Router = Router;\nRouter.Route = Route;\nRouter.Link = Link;\nRouter.exec = exec;\n\nexport { subscribers, getCurrentUrl, route, Router, Route, Link, exec };\nexport default Router;\n", "import { options } from 'preact';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Component} */\nlet currentComponent;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\nlet oldBeforeDiff = options._diff;\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\n\nconst RAF_TIMEOUT = 100;\nlet prevRaf;\n\noptions._diff = vnode => {\n\tcurrentComponent = null;\n\tif (oldBeforeDiff) oldBeforeDiff(vnode);\n};\n\noptions._render = vnode => {\n\tif (oldBeforeRender) oldBeforeRender(vnode);\n\n\tcurrentComponent = vnode._component;\n\tcurrentIndex = 0;\n\n\tconst hooks = currentComponent.__hooks;\n\tif (hooks) {\n\t\thooks._pendingEffects.forEach(invokeCleanup);\n\t\thooks._pendingEffects.forEach(invokeEffect);\n\t\thooks._pendingEffects = [];\n\t}\n};\n\noptions.diffed = vnode => {\n\tif (oldAfterDiff) oldAfterDiff(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks && c.__hooks._pendingEffects.length) {\n\t\tafterPaint(afterPaintEffects.push(c));\n\t}\n\tcurrentComponent = null;\n};\n\noptions._commit = (vnode, commitQueue) => {\n\tcommitQueue.some(component => {\n\t\ttry {\n\t\t\tcomponent._renderCallbacks.forEach(invokeCleanup);\n\t\t\tcomponent._renderCallbacks = component._renderCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(c => {\n\t\t\t\tif (c._renderCallbacks) c._renderCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(vnode, commitQueue);\n};\n\noptions.unmount = vnode => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\ttry {\n\t\t\tc.__hooks._list.forEach(invokeCleanup);\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {any}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentComponent, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentComponent.__hooks ||\n\t\t(currentComponent.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({});\n\t}\n\treturn hooks._list[index];\n}\n\n/**\n * @param {import('./index').StateUpdater<any>} [initialState]\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @param {import('./index').Reducer<any, any>} reducer\n * @param {import('./index').StateUpdater<any>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ any, (state: any) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._component) {\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst nextValue = hookState._reducer(hookState._value[0], action);\n\t\t\t\tif (hookState._value[0] !== nextValue) {\n\t\t\t\t\thookState._value = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._component.setState({});\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\n\t\thookState._component = currentComponent;\n\t}\n\n\treturn hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {any[]} args\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._args = args;\n\n\t\tcurrentComponent.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {any[]} args\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._args = args;\n\n\t\tcurrentComponent._renderCallbacks.push(state);\n\t}\n}\n\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {any[]} args\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') ref(createHandle());\n\t\t\telse if (ref) ref.current = createHandle();\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @param {() => any} factory\n * @param {any[]} args\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._value = factory();\n\t\tstate._args = args;\n\t\tstate._factory = factory;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {any[]} args\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = currentComponent.context[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\t/** @type {import('./internal').ContextHookState} */\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider.sub(currentComponent);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(formatter ? formatter(value) : value);\n\t}\n}\n\n/**\n * @param {(error: any) => void} cb\n */\nexport function useErrorBoundary(cb) {\n\t/** @type {import('./internal').ErrorBoundaryHookState} */\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\tif (!currentComponent.componentDidCatch) {\n\t\tcurrentComponent.componentDidCatch = err => {\n\t\t\tif (state._value) state._value(err);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tafterPaintEffects.forEach(component => {\n\t\tif (component._parentDom) {\n\t\t\ttry {\n\t\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\t} catch (e) {\n\t\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\t\toptions._catchError(e, component._vnode);\n\t\t\t}\n\t\t}\n\t});\n\tafterPaintEffects = [];\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').EffectHookState} hook\n */\nfunction invokeCleanup(hook) {\n\t// A hook cleanup can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\tif (typeof hook._cleanup == 'function') hook._cleanup();\n\tcurrentComponent = comp;\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n */\nfunction invokeEffect(hook) {\n\t// A hook call can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\thook._cleanup = hook._value();\n\tcurrentComponent = comp;\n}\n\n/**\n * @param {any[]} oldArgs\n * @param {any[]} newArgs\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn (\n\t\t!oldArgs ||\n\t\toldArgs.length !== newArgs.length ||\n\t\tnewArgs.some((arg, index) => arg !== oldArgs[index])\n\t);\n}\n\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n", "import { Ref } from 'preact/hooks';\r\n\r\n/**\r\n * https://usefulangle.com/post/17/html5-canvas-drawing-1px-crisp-straight-lines\r\n * @param n\r\n */\r\nexport const lineY = (n: number) => {\r\n    return Math.round(n) + 0.5;\r\n};\r\n\r\n/**\r\n * return canvas and 2d context from 'ref'\r\n * @param ref\r\n * @returns\r\n */\r\nexport const getCanvasContext = (ref: Ref<HTMLCanvasElement>) => {\r\n    const canvas = ref.current;\r\n    const ctx = canvas.getContext('2d') as CanvasRenderingContext2D;\r\n\r\n    return { canvas, ctx };\r\n};\r\n\r\n/**\r\n * get the position relative to the canvas\r\n * @param canvas\r\n * @param e\r\n * @returns\r\n */\r\nexport const getCanvasPos = (canvas: HTMLCanvasElement, e: MouseEvent) => {\r\n    const r = canvas.getBoundingClientRect();\r\n    const x = e.clientX - r.left;\r\n    const y = e.clientY - r.top;\r\n\r\n    return { x, y };\r\n};\r\n", "export const lerp = (x: number, y: number, a: number) => x * (1 - a) + y * a;\r\n\r\nexport const invlerp = (x: number, y: number, a: number) =>\r\n    clamp((a - x) / (y - x));\r\n\r\nexport const clamp = (a: number, min = 0, max = 1) =>\r\n    Math.min(max, Math.max(min, a));\r\n\r\n/**\r\n * linear interpolation (remap) using (lerp) and (invlerp)\r\n * @param x1 x from\r\n * @param y1 y from\r\n * @param x2 x to\r\n * @param y2 y to\r\n * @param v value to fit\r\n * @returns\r\n */\r\nexport const range = (\r\n    x1: number,\r\n    y1: number,\r\n    x2: number,\r\n    y2: number,\r\n    v: number\r\n) => lerp(x2, y2, invlerp(x1, y1, v));\r\n", "import { IOrderBookItem } from '@components/OrderBook/OrderBook.types';\r\nimport { IMarketItem, IMarketSpark } from 'src/types/data.types';\r\nimport { lineY } from './canvas.utils';\r\nimport { range } from './math.utils';\r\n\r\n/**\r\n * get min/max for X/Y\r\n * @param items\r\n * @returns\r\n */\r\nexport const getMinMaxMarket = (items: IMarketItem[]) => {\r\n    let minX = items[0];\r\n    let maxX = items[0];\r\n\r\n    let minY = items[0];\r\n    let maxY = items[0];\r\n\r\n    for (const item of items) {\r\n        if (maxX.openTime < item.openTime) maxX = item;\r\n        if (minX.openTime > item.openTime) minX = item;\r\n\r\n        if (maxY.spark.close < item.spark.close) maxY = item;\r\n        if (minY.spark.close > item.spark.close) minY = item;\r\n    }\r\n\r\n    return { minX, maxX, minY, maxY };\r\n};\r\n\r\n/**\r\n * interpolate data to fit frame\r\n * @param height height to fit into\r\n * @param width width to fit into\r\n * @param items items to fit\r\n */\r\nexport const getIplMarket = (\r\n    height: number,\r\n    width: number,\r\n    items: IMarketItem[]\r\n) => {\r\n    const { minX, maxX, minY, maxY } = getMinMaxMarket(items);\r\n\r\n    const padX = 0;\r\n    const padY = 0;\r\n\r\n    const ipl = items.map(item => {\r\n        const fit = { ...item }; // shallow copy\r\n        fit.spark = { ...item.spark }; // shallow copy\r\n\r\n        // fit 'x'\r\n        const x = range(\r\n            minX.openTime,\r\n            maxX.openTime,\r\n            padX,\r\n            width - padX,\r\n            item.openTime\r\n        );\r\n        fit.openTime = lineY(x);\r\n\r\n        // fit 'y'\r\n        Object.keys(fit.spark).forEach(spark => {\r\n            const key = spark as keyof IMarketSpark;\r\n\r\n            // interpolate\r\n            const y = range(\r\n                minY.spark.low,\r\n                maxY.spark.high,\r\n                padY,\r\n                height - padY,\r\n                item.spark[key]\r\n            );\r\n\r\n            // invert Y for chart to trend in the right direction\r\n            fit.spark[key] = lineY(height - y);\r\n        });\r\n\r\n        return fit;\r\n    }) as IMarketItem[];\r\n\r\n    return { ipl, minX, maxX, minY, maxY };\r\n};\r\n\r\n/**\r\n *  * which item is closest to our mouse position\r\n * @param moveX\r\n * @param ipl\r\n * @param items\r\n * @returns\r\n */\r\nexport const getHoverMarket = (\r\n    moveX: number,\r\n    ipl: IMarketItem[],\r\n    items: IMarketItem[]\r\n) => {\r\n    let iplHover = ipl[0];\r\n    let itemHover = items[0];\r\n\r\n    for (let i = 0; i < ipl.length; i++) {\r\n        const distanceA = Math.abs(moveX - ipl[i].openTime);\r\n        const distanceB = Math.abs(moveX - iplHover.openTime);\r\n\r\n        if (distanceA < distanceB) {\r\n            iplHover = ipl[i];\r\n            itemHover = items[i];\r\n        }\r\n    }\r\n\r\n    return { iplHover, itemHover };\r\n};\r\n\r\n/**\r\n * get min/max of x/y\r\n * @param items\r\n * @returns\r\n */\r\nconst getMinMaxOrderBook = (items: IOrderBookItem[]) => {\r\n    let minX = items[0];\r\n    let maxX = items[0];\r\n\r\n    let minY = items[0];\r\n    let maxY = items[0];\r\n\r\n    for (const item of items) {\r\n        if (maxX.totalVolume < item.totalVolume) maxX = item;\r\n        if (minX.totalVolume > item.totalVolume) minX = item;\r\n\r\n        if (maxY.totalPercent < item.totalPercent) maxY = item;\r\n        if (minY.totalPercent > item.totalPercent) minY = item;\r\n    }\r\n\r\n    return { minX, maxX, minY, maxY };\r\n};\r\n\r\n/**\r\n * interpolate data to fit frame\r\n * @param height\r\n * @param width\r\n * @param items\r\n * @returns\r\n */\r\nexport const getIplOrderBook = (\r\n    height: number,\r\n    width: number,\r\n    items: IOrderBookItem[]\r\n) => {\r\n    //\r\n    const { minX, maxX, minY, maxY } = getMinMaxOrderBook(items);\r\n\r\n    const ipl = items.map(item => {\r\n        const fit = { ...item }; // shallow copy\r\n\r\n        // fit 'x'\r\n        const x = range(\r\n            minX.totalVolume,\r\n            maxX.totalVolume,\r\n            0,\r\n            width,\r\n            item.totalVolume\r\n        );\r\n        fit.totalVolume = lineY(x);\r\n\r\n        // fit 'y'\r\n        const y = range(\r\n            minY.totalPercent,\r\n            maxY.totalPercent,\r\n            0,\r\n            height,\r\n            item.totalPercent\r\n        );\r\n        fit.totalPercent = lineY(y);\r\n\r\n        return fit;\r\n    }) as IOrderBookItem[];\r\n\r\n    return { ipl, minX, maxX, minY, maxY };\r\n};\r\n\r\n/**\r\n * which items is closest to our mouse position\r\n * @param moveY\r\n * @param ipl\r\n * @param items\r\n * @returns\r\n */\r\nexport const getHoverOrderBook = (\r\n    moveY: number,\r\n    ipl: IOrderBookItem[],\r\n    items: IOrderBookItem[]\r\n) => {\r\n    let iplHover = ipl[0];\r\n    let itemHover = items[0];\r\n\r\n    for (let i = 0; i < ipl.length; i++) {\r\n        const distanceA = Math.abs(moveY - ipl[i].totalPercent);\r\n        const distanceB = Math.abs(moveY - iplHover.totalPercent);\r\n\r\n        if (distanceA < distanceB) {\r\n            iplHover = ipl[i];\r\n            itemHover = items[i];\r\n        }\r\n    }\r\n\r\n    return { iplHover, itemHover };\r\n};\r\n", "/**\r\n * round base + decimals to N digits\r\n * @param input\r\n * @param digits\r\n * @returns\r\n */\r\nexport const getNDigits = (input: number, digits: number = 4): string => {\r\n    const base = input.toString().split('.')[0];\r\n    const round = input.toFixed(digits - base.length);\r\n\r\n    return round;\r\n};\r\n\r\n/**\r\n * denote number to K/M/B\r\n * @param n\r\n */\r\nexport const getDenoted = (n: number) => {\r\n    if (n < 1e3) return n;\r\n    if (n >= 1e3 && n < 1e6) return +(n / 1e3).toFixed(1) + 'K';\r\n    if (n >= 1e6 && n < 1e9) return +(n / 1e6).toFixed(1) + 'M';\r\n    if (n >= 1e9 && n < 1e12) return +(n / 1e9).toFixed(1) + 'B';\r\n};\r\n", "export enum EMarketTrend {\r\n    Long = 'long',\r\n    Short = 'short'\r\n}\r\n\r\nexport interface IMarketTrend {\r\n    percent: string;\r\n    trend: EMarketTrend;\r\n}\r\n", "// utils\r\nimport { getMinMaxMarket } from '@utils/data.utils';\r\nimport { getDenoted, getNDigits } from '@utils/number.utils';\r\n\r\n// types\r\nimport { IMarketItem, IMarketSpark } from 'src/types/data.types';\r\nimport { EMarketTrend, IMarketTrend } from './MarketBox.types';\r\n\r\n/**\r\n * @param price\r\n * @param digits amount of digits to round base + decimals to\r\n */\r\nconst getPrice = (price: number, digits: number = 6): string => {\r\n    return getNDigits(price, digits);\r\n};\r\n\r\n/**\r\n * get long/short trend and suffix depending on market start/end\r\n * @param first first ohlc item in (open) time\r\n * @param last last ohlc item in (open) time\r\n * @returns\r\n */\r\nconst getTrend = (first: IMarketSpark, last: IMarketSpark) => {\r\n    const change = ((last.close - first.close) / first.close) * 100;\r\n\r\n    const trend = change > 0 ? EMarketTrend.Long : EMarketTrend.Short;\r\n    const percent = `${change > 0 ? '+' : '-'}${Math.abs(change).toFixed(2)}%`;\r\n\r\n    return { percent, trend } as IMarketTrend;\r\n};\r\n\r\n/**\r\n * calculate volume and transform to denotion\r\n * @param items\r\n * @returns\r\n */\r\nexport const getVolume = (items: IMarketItem[]) => {\r\n    let volume = 0;\r\n    for (let i = 0; i < items.length; i++) {\r\n        volume += items[i].volume;\r\n    }\r\n    return volume;\r\n};\r\n\r\n/**\r\n * process price, color, trend and volume\r\n * @param items\r\n */\r\nexport const getMarketInfo = (items: IMarketItem[]) => {\r\n    const { minX, maxX } = getMinMaxMarket(items);\r\n\r\n    const price = getPrice(maxX.spark.close);\r\n    const volume = getDenoted(getVolume(items));\r\n\r\n    const { percent, trend } = getTrend(minX.spark, maxX.spark);\r\n    const color = `var(--clr-${trend})`;\r\n\r\n    return { price, volume, percent, trend, color };\r\n};\r\n", "import { h } from 'preact';\r\n\r\n// utils\r\nimport { getIplMarket } from '@utils/data.utils';\r\nimport { getMarketInfo } from './MarketBox.utils';\r\n\r\n// types\r\nimport { IMarketItem, IMarketState } from 'src/types/data.types';\r\n\r\n// styles\r\nimport './MarketBox.module.scss';\r\n\r\n/**\r\n * interpolate data and render <polyline> svg\r\n * @param width viewbox width\r\n * @param height viewbox height\r\n * @param items\r\n * @returns\r\n */\r\nconst getSvg = (width: number, height: number, items: IMarketItem[]) => {\r\n    // fit viewbox\r\n    const { ipl } = getIplMarket(height, width, items);\r\n\r\n    // build svg\r\n    return ipl\r\n        .map(item => {\r\n            const {\r\n                openTime: x,\r\n                spark: { close: y }\r\n            } = item;\r\n\r\n            return x + ',' + y;\r\n        })\r\n        .join(' ');\r\n};\r\n\r\nexport interface IMarketBoxProps {\r\n    state: IMarketState;\r\n}\r\n\r\nexport const MarketBox = ({ state }: IMarketBoxProps) => {\r\n    const { key, name, rank, items } = state;\r\n\r\n    // svg frame\r\n    const width = 500;\r\n    const height = 100;\r\n\r\n    const viewBox = `0 0 ${width} ${height}`;\r\n    const svg = getSvg(width, height, items);\r\n\r\n    // info\r\n    const { price, volume, trend, percent, color } = getMarketInfo(items);\r\n\r\n    return (\r\n        <div className={`market-box market-box--${trend}`}>\r\n            <div className=\"market-box__title\">\r\n                <span className=\"title--token\">\r\n                    {name} ({key})\r\n                </span>\r\n                <span className=\"title--rank\" style={{ color }}>\r\n                    #{rank}\r\n                </span>\r\n            </div>\r\n            <div className=\"market-box__price\">\r\n                <span className=\"price--text\">{price}</span>\r\n                <span className=\"price--change\" style={{ color }}>\r\n                    {percent}\r\n                </span>\r\n            </div>\r\n            <div className=\"market-box__volume\">\r\n                <span className=\"clr-text-weak\">Volume</span>\r\n                <span className=\"volume--percent\">{volume}</span>\r\n            </div>\r\n\r\n            <svg\r\n                className=\"market-box__svg\"\r\n                viewBox={viewBox}\r\n                style={{ width: '100%' }}\r\n            >\r\n                <polyline\r\n                    fill=\"none\"\r\n                    stroke={color}\r\n                    strokeLinejoin=\"round\"\r\n                    stroke-width=\"2\"\r\n                    points={svg}\r\n                />\r\n            </svg>\r\n        </div>\r\n    );\r\n};\r\n", "/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Check if two objects have a different shape\n * @param {object} a\n * @param {object} b\n * @returns {boolean}\n */\nexport function shallowDiffers(a, b) {\n\tfor (let i in a) if (i !== '__source' && !(i in b)) return true;\n\tfor (let i in b) if (i !== '__source' && a[i] !== b[i]) return true;\n\treturn false;\n}\n\nexport function removeNode(node) {\n\tlet parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n", "import { Component } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Component class with a predefined `shouldComponentUpdate` implementation\n */\nexport function PureComponent(p) {\n\tthis.props = p;\n}\nPureComponent.prototype = new Component();\n// Some third-party libraries check if this property is present\nPureComponent.prototype.isPureReactComponent = true;\nPureComponent.prototype.shouldComponentUpdate = function(props, state) {\n\treturn shallowDiffers(this.props, props) || shallowDiffers(this.state, state);\n};\n", "import { createElement } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Memoize a component, so that it only updates when the props actually have\n * changed. This was previously known as `React.pure`.\n * @param {import('./internal').FunctionComponent} c functional component\n * @param {(prev: object, next: object) => boolean} [comparer] Custom equality function\n * @returns {import('./internal').FunctionComponent}\n */\nexport function memo(c, comparer) {\n\tfunction shouldUpdate(nextProps) {\n\t\tlet ref = this.props.ref;\n\t\tlet updateRef = ref == nextProps.ref;\n\t\tif (!updateRef && ref) {\n\t\t\tref.call ? ref(null) : (ref.current = null);\n\t\t}\n\n\t\tif (!comparer) {\n\t\t\treturn shallowDiffers(this.props, nextProps);\n\t\t}\n\n\t\treturn !comparer(this.props, nextProps) || !updateRef;\n\t}\n\n\tfunction Memoed(props) {\n\t\tthis.shouldComponentUpdate = shouldUpdate;\n\t\treturn createElement(c, props);\n\t}\n\tMemoed.displayName = 'Memo(' + (c.displayName || c.name) + ')';\n\tMemoed.prototype.isReactComponent = true;\n\tMemoed._forwarded = true;\n\treturn Memoed;\n}\n", "import { options } from 'preact';\nimport { assign } from './util';\n\nlet oldDiffHook = options._diff;\noptions._diff = vnode => {\n\tif (vnode.type && vnode.type._forwarded && vnode.ref) {\n\t\tvnode.props.ref = vnode.ref;\n\t\tvnode.ref = null;\n\t}\n\tif (oldDiffHook) oldDiffHook(vnode);\n};\n\nexport const REACT_FORWARD_SYMBOL =\n\t(typeof Symbol != 'undefined' &&\n\t\tSymbol.for &&\n\t\tSymbol.for('react.forward_ref')) ||\n\t0xf47;\n\n/**\n * Pass ref down to a child. This is mainly used in libraries with HOCs that\n * wrap components. Using `forwardRef` there is an easy way to get a reference\n * of the wrapped component instead of one of the wrapper itself.\n * @param {import('./index').ForwardFn} fn\n * @returns {import('./internal').FunctionComponent}\n */\nexport function forwardRef(fn) {\n\t// We always have ref in props.ref, except for\n\t// mobx-react. It will call this function directly\n\t// and always pass ref as the second argument.\n\tfunction Forwarded(props, ref) {\n\t\tlet clone = assign({}, props);\n\t\tdelete clone.ref;\n\t\tref = props.ref || ref;\n\t\treturn fn(\n\t\t\tclone,\n\t\t\t!ref || (typeof ref === 'object' && !('current' in ref)) ? null : ref\n\t\t);\n\t}\n\n\t// mobx-react checks for this being present\n\tForwarded.$$typeof = REACT_FORWARD_SYMBOL;\n\t// mobx-react heavily relies on implementation details.\n\t// It expects an object here with a `render` property,\n\t// and prototype.render will fail. Without this\n\t// mobx-react throws.\n\tForwarded.render = Forwarded;\n\n\tForwarded.prototype.isReactComponent = Forwarded._forwarded = true;\n\tForwarded.displayName = 'ForwardRef(' + (fn.displayName || fn.name) + ')';\n\treturn Forwarded;\n}\n", "import { toChildArray } from 'preact';\n\nconst mapFn = (children, fn) => {\n\tif (children == null) return null;\n\treturn toChildArray(toChildArray(children).map(fn));\n};\n\n// This API is completely unnecessary for Preact, so it's basically passthrough.\nexport const Children = {\n\tmap: mapFn,\n\tforEach: mapFn,\n\tcount(children) {\n\t\treturn children ? toChildArray(children).length : 0;\n\t},\n\tonly(children) {\n\t\tconst normalized = toChildArray(children);\n\t\tif (normalized.length !== 1) throw 'Children.only';\n\t\treturn normalized[0];\n\t},\n\ttoArray: toChildArray\n};\n", "import { Component, createElement, options, Fragment } from 'preact';\nimport { assign } from './util';\n\nconst oldCatchError = options._catchError;\noptions._catchError = function(error, newVNode, oldVNode) {\n\tif (error.then) {\n\t\t/** @type {import('./internal').Component} */\n\t\tlet component;\n\t\tlet vnode = newVNode;\n\n\t\tfor (; (vnode = vnode._parent); ) {\n\t\t\tif ((component = vnode._component) && component._childDidSuspend) {\n\t\t\t\tif (newVNode._dom == null) {\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t}\n\t\t\t\t// Don't call oldCatchError if we found a Suspense\n\t\t\t\treturn component._childDidSuspend(error, newVNode);\n\t\t\t}\n\t\t}\n\t}\n\toldCatchError(error, newVNode, oldVNode);\n};\n\nconst oldUnmount = options.unmount;\noptions.unmount = function(vnode) {\n\t/** @type {import('./internal').Component} */\n\tconst component = vnode._component;\n\tif (component && component._onResolve) {\n\t\tcomponent._onResolve();\n\t}\n\n\t// if the component is still hydrating\n\t// most likely it is because the component is suspended\n\t// we set the vnode.type as `null` so that it is not a typeof function\n\t// so the unmount will remove the vnode._dom\n\tif (component && vnode._hydrating === true) {\n\t\tvnode.type = null;\n\t}\n\n\tif (oldUnmount) oldUnmount(vnode);\n};\n\nfunction detachedClone(vnode, detachedParent, parentDom) {\n\tif (vnode) {\n\t\tif (vnode._component && vnode._component.__hooks) {\n\t\t\tvnode._component.__hooks._list.forEach(effect => {\n\t\t\t\tif (typeof effect._cleanup == 'function') effect._cleanup();\n\t\t\t});\n\n\t\t\tvnode._component.__hooks = null;\n\t\t}\n\n\t\tvnode = assign({}, vnode);\n\t\tif (vnode._component != null) {\n\t\t\tif (vnode._component._parentDom === parentDom) {\n\t\t\t\tvnode._component._parentDom = detachedParent;\n\t\t\t}\n\t\t\tvnode._component = null;\n\t\t}\n\n\t\tvnode._children =\n\t\t\tvnode._children &&\n\t\t\tvnode._children.map(child =>\n\t\t\t\tdetachedClone(child, detachedParent, parentDom)\n\t\t\t);\n\t}\n\n\treturn vnode;\n}\n\nfunction removeOriginal(vnode, detachedParent, originalParent) {\n\tif (vnode) {\n\t\tvnode._original = null;\n\t\tvnode._children =\n\t\t\tvnode._children &&\n\t\t\tvnode._children.map(child =>\n\t\t\t\tremoveOriginal(child, detachedParent, originalParent)\n\t\t\t);\n\n\t\tif (vnode._component) {\n\t\t\tif (vnode._component._parentDom === detachedParent) {\n\t\t\t\tif (vnode._dom) {\n\t\t\t\t\toriginalParent.insertBefore(vnode._dom, vnode._nextDom);\n\t\t\t\t}\n\t\t\t\tvnode._component._force = true;\n\t\t\t\tvnode._component._parentDom = originalParent;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn vnode;\n}\n\n// having custom inheritance instead of a class here saves a lot of bytes\nexport function Suspense() {\n\t// we do not call super here to golf some bytes...\n\tthis._pendingSuspensionCount = 0;\n\tthis._suspenders = null;\n\tthis._detachOnNextRender = null;\n}\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspense.prototype = new Component();\n\n/**\n * @this {import('./internal').SuspenseComponent}\n * @param {Promise} promise The thrown promise\n * @param {import('./internal').VNode<any, any>} suspendingVNode The suspending component\n */\nSuspense.prototype._childDidSuspend = function(promise, suspendingVNode) {\n\tconst suspendingComponent = suspendingVNode._component;\n\n\t/** @type {import('./internal').SuspenseComponent} */\n\tconst c = this;\n\n\tif (c._suspenders == null) {\n\t\tc._suspenders = [];\n\t}\n\tc._suspenders.push(suspendingComponent);\n\n\tconst resolve = suspended(c._vnode);\n\n\tlet resolved = false;\n\tconst onResolved = () => {\n\t\tif (resolved) return;\n\n\t\tresolved = true;\n\t\tsuspendingComponent._onResolve = null;\n\n\t\tif (resolve) {\n\t\t\tresolve(onSuspensionComplete);\n\t\t} else {\n\t\t\tonSuspensionComplete();\n\t\t}\n\t};\n\n\tsuspendingComponent._onResolve = onResolved;\n\n\tconst onSuspensionComplete = () => {\n\t\tif (!--c._pendingSuspensionCount) {\n\t\t\t// If the suspension was during hydration we don't need to restore the\n\t\t\t// suspended children into the _children array\n\t\t\tif (c.state._suspended) {\n\t\t\t\tconst suspendedVNode = c.state._suspended;\n\t\t\t\tc._vnode._children[0] = removeOriginal(\n\t\t\t\t\tsuspendedVNode,\n\t\t\t\t\tsuspendedVNode._component._parentDom,\n\t\t\t\t\tsuspendedVNode._component._originalParentDom\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tc.setState({ _suspended: (c._detachOnNextRender = null) });\n\n\t\t\tlet suspended;\n\t\t\twhile ((suspended = c._suspenders.pop())) {\n\t\t\t\tsuspended.forceUpdate();\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * We do not set `suspended: true` during hydration because we want the actual markup\n\t * to remain on screen and hydrate it when the suspense actually gets resolved.\n\t * While in non-hydration cases the usual fallback -> component flow would occour.\n\t */\n\tconst wasHydrating = suspendingVNode._hydrating === true;\n\tif (!c._pendingSuspensionCount++ && !wasHydrating) {\n\t\tc.setState({ _suspended: (c._detachOnNextRender = c._vnode._children[0]) });\n\t}\n\tpromise.then(onResolved, onResolved);\n};\n\nSuspense.prototype.componentWillUnmount = function() {\n\tthis._suspenders = [];\n};\n\n/**\n * @this {import('./internal').SuspenseComponent}\n * @param {import('./internal').SuspenseComponent[\"props\"]} props\n * @param {import('./internal').SuspenseState} state\n */\nSuspense.prototype.render = function(props, state) {\n\tif (this._detachOnNextRender) {\n\t\t// When the Suspense's _vnode was created by a call to createVNode\n\t\t// (i.e. due to a setState further up in the tree)\n\t\t// it's _children prop is null, in this case we \"forget\" about the parked vnodes to detach\n\t\tif (this._vnode._children) {\n\t\t\tconst detachedParent = document.createElement('div');\n\t\t\tconst detachedComponent = this._vnode._children[0]._component;\n\t\t\tthis._vnode._children[0] = detachedClone(\n\t\t\t\tthis._detachOnNextRender,\n\t\t\t\tdetachedParent,\n\t\t\t\t(detachedComponent._originalParentDom = detachedComponent._parentDom)\n\t\t\t);\n\t\t}\n\n\t\tthis._detachOnNextRender = null;\n\t}\n\n\t// Wrap fallback tree in a VNode that prevents itself from being marked as aborting mid-hydration:\n\t/** @type {import('./internal').VNode} */\n\tconst fallback =\n\t\tstate._suspended && createElement(Fragment, null, props.fallback);\n\tif (fallback) fallback._hydrating = null;\n\n\treturn [\n\t\tcreateElement(Fragment, null, state._suspended ? null : props.children),\n\t\tfallback\n\t];\n};\n\n/**\n * Checks and calls the parent component's _suspended method, passing in the\n * suspended vnode. This is a way for a parent (e.g. SuspenseList) to get notified\n * that one of its children/descendants suspended.\n *\n * The parent MAY return a callback. The callback will get called when the\n * suspension resolves, notifying the parent of the fact.\n * Moreover, the callback gets function `unsuspend` as a parameter. The resolved\n * child descendant will not actually get unsuspended until `unsuspend` gets called.\n * This is a way for the parent to delay unsuspending.\n *\n * If the parent does not return a callback then the resolved vnode\n * gets unsuspended immediately when it resolves.\n *\n * @param {import('./internal').VNode} vnode\n * @returns {((unsuspend: () => void) => void)?}\n */\nexport function suspended(vnode) {\n\t/** @type {import('./internal').Component} */\n\tlet component = vnode._parent._component;\n\treturn component && component._suspended && component._suspended(vnode);\n}\n\nexport function lazy(loader) {\n\tlet prom;\n\tlet component;\n\tlet error;\n\n\tfunction Lazy(props) {\n\t\tif (!prom) {\n\t\t\tprom = loader();\n\t\t\tprom.then(\n\t\t\t\texports => {\n\t\t\t\t\tcomponent = exports.default || exports;\n\t\t\t\t},\n\t\t\t\te => {\n\t\t\t\t\terror = e;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tif (!component) {\n\t\t\tthrow prom;\n\t\t}\n\n\t\treturn createElement(component, props);\n\t}\n\n\tLazy.displayName = 'Lazy';\n\tLazy._forwarded = true;\n\treturn Lazy;\n}\n", "import { Component, toChildArray } from 'preact';\nimport { suspended } from './suspense.js';\n\n// Indexes to linked list nodes (nodes are stored as arrays to save bytes).\nconst SUSPENDED_COUNT = 0;\nconst RESOLVED_COUNT = 1;\nconst NEXT_NODE = 2;\n\n// Having custom inheritance instead of a class here saves a lot of bytes.\nexport function SuspenseList() {\n\tthis._next = null;\n\tthis._map = null;\n}\n\n// Mark one of child's earlier suspensions as resolved.\n// Some pending callbacks may become callable due to this\n// (e.g. the last suspended descendant gets resolved when\n// revealOrder === 'together'). Process those callbacks as well.\nconst resolve = (list, child, node) => {\n\tif (++node[RESOLVED_COUNT] === node[SUSPENDED_COUNT]) {\n\t\t// The number a child (or any of its descendants) has been suspended\n\t\t// matches the number of times it's been resolved. Therefore we\n\t\t// mark the child as completely resolved by deleting it from ._map.\n\t\t// This is used to figure out when *all* children have been completely\n\t\t// resolved when revealOrder is 'together'.\n\t\tlist._map.delete(child);\n\t}\n\n\t// If revealOrder is falsy then we can do an early exit, as the\n\t// callbacks won't get queued in the node anyway.\n\t// If revealOrder is 'together' then also do an early exit\n\t// if all suspended descendants have not yet been resolved.\n\tif (\n\t\t!list.props.revealOrder ||\n\t\t(list.props.revealOrder[0] === 't' && list._map.size)\n\t) {\n\t\treturn;\n\t}\n\n\t// Walk the currently suspended children in order, calling their\n\t// stored callbacks on the way. Stop if we encounter a child that\n\t// has not been completely resolved yet.\n\tnode = list._next;\n\twhile (node) {\n\t\twhile (node.length > 3) {\n\t\t\tnode.pop()();\n\t\t}\n\t\tif (node[RESOLVED_COUNT] < node[SUSPENDED_COUNT]) {\n\t\t\tbreak;\n\t\t}\n\t\tlist._next = node = node[NEXT_NODE];\n\t}\n};\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspenseList.prototype = new Component();\n\nSuspenseList.prototype._suspended = function(child) {\n\tconst list = this;\n\tconst delegated = suspended(list._vnode);\n\n\tlet node = list._map.get(child);\n\tnode[SUSPENDED_COUNT]++;\n\n\treturn unsuspend => {\n\t\tconst wrappedUnsuspend = () => {\n\t\t\tif (!list.props.revealOrder) {\n\t\t\t\t// Special case the undefined (falsy) revealOrder, as there\n\t\t\t\t// is no need to coordinate a specific order or unsuspends.\n\t\t\t\tunsuspend();\n\t\t\t} else {\n\t\t\t\tnode.push(unsuspend);\n\t\t\t\tresolve(list, child, node);\n\t\t\t}\n\t\t};\n\t\tif (delegated) {\n\t\t\tdelegated(wrappedUnsuspend);\n\t\t} else {\n\t\t\twrappedUnsuspend();\n\t\t}\n\t};\n};\n\nSuspenseList.prototype.render = function(props) {\n\tthis._next = null;\n\tthis._map = new Map();\n\n\tconst children = toChildArray(props.children);\n\tif (props.revealOrder && props.revealOrder[0] === 'b') {\n\t\t// If order === 'backwards' (or, well, anything starting with a 'b')\n\t\t// then flip the child list around so that the last child will be\n\t\t// the first in the linked list.\n\t\tchildren.reverse();\n\t}\n\t// Build the linked list. Iterate through the children in reverse order\n\t// so that `_next` points to the first linked list node to be resolved.\n\tfor (let i = children.length; i--; ) {\n\t\t// Create a new linked list node as an array of form:\n\t\t// \t[suspended_count, resolved_count, next_node]\n\t\t// where suspended_count and resolved_count are numeric counters for\n\t\t// keeping track how many times a node has been suspended and resolved.\n\t\t//\n\t\t// Note that suspended_count starts from 1 instead of 0, so we can block\n\t\t// processing callbacks until componentDidMount has been called. In a sense\n\t\t// node is suspended at least until componentDidMount gets called!\n\t\t//\n\t\t// Pending callbacks are added to the end of the node:\n\t\t// \t[suspended_count, resolved_count, next_node, callback_0, callback_1, ...]\n\t\tthis._map.set(children[i], (this._next = [1, 0, this._next]));\n\t}\n\treturn props.children;\n};\n\nSuspenseList.prototype.componentDidUpdate = SuspenseList.prototype.componentDidMount = function() {\n\t// Iterate through all children after mounting for two reasons:\n\t// 1. As each node[SUSPENDED_COUNT] starts from 1, this iteration increases\n\t//    each node[RELEASED_COUNT] by 1, therefore balancing the counters.\n\t//    The nodes can now be completely consumed from the linked list.\n\t// 2. Handle nodes that might have gotten resolved between render and\n\t//    componentDidMount.\n\tthis._map.forEach((node, child) => {\n\t\tresolve(this, child, node);\n\t});\n};\n", "import { createElement, render } from 'preact';\n\n/**\n * @param {import('../../src/index').RenderableProps<{ context: any }>} props\n */\nfunction ContextProvider(props) {\n\tthis.getChildContext = () => props.context;\n\treturn props.children;\n}\n\n/**\n * Portal component\n * @this {import('./internal').Component}\n * @param {object | null | undefined} props\n *\n * TODO: use createRoot() instead of fake root\n */\nfunction Portal(props) {\n\tconst _this = this;\n\tlet container = props._container;\n\n\t_this.componentWillUnmount = function() {\n\t\trender(null, _this._temp);\n\t\t_this._temp = null;\n\t\t_this._container = null;\n\t};\n\n\t// When we change container we should clear our old container and\n\t// indicate a new mount.\n\tif (_this._container && _this._container !== container) {\n\t\t_this.componentWillUnmount();\n\t}\n\n\t// When props.vnode is undefined/false/null we are dealing with some kind of\n\t// conditional vnode. This should not trigger a render.\n\tif (props._vnode) {\n\t\tif (!_this._temp) {\n\t\t\t_this._container = container;\n\n\t\t\t// Create a fake DOM parent node that manages a subset of `container`'s children:\n\t\t\t_this._temp = {\n\t\t\t\tnodeType: 1,\n\t\t\t\tparentNode: container,\n\t\t\t\tchildNodes: [],\n\t\t\t\tappendChild(child) {\n\t\t\t\t\tthis.childNodes.push(child);\n\t\t\t\t\t_this._container.appendChild(child);\n\t\t\t\t},\n\t\t\t\tinsertBefore(child, before) {\n\t\t\t\t\tthis.childNodes.push(child);\n\t\t\t\t\t_this._container.appendChild(child);\n\t\t\t\t},\n\t\t\t\tremoveChild(child) {\n\t\t\t\t\tthis.childNodes.splice(this.childNodes.indexOf(child) >>> 1, 1);\n\t\t\t\t\t_this._container.removeChild(child);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// Render our wrapping element into temp.\n\t\trender(\n\t\t\tcreateElement(ContextProvider, { context: _this.context }, props._vnode),\n\t\t\t_this._temp\n\t\t);\n\t}\n\t// When we come from a conditional render, on a mounted\n\t// portal we should clear the DOM.\n\telse if (_this._temp) {\n\t\t_this.componentWillUnmount();\n\t}\n}\n\n/**\n * Create a `Portal` to continue rendering the vnode tree at a different DOM node\n * @param {import('./internal').VNode} vnode The vnode to render\n * @param {import('./internal').PreactElement} container The DOM node to continue rendering in to.\n */\nexport function createPortal(vnode, container) {\n\treturn createElement(Portal, { _vnode: vnode, _container: container });\n}\n", "import {\n\trender as preactRender,\n\thydrate as preactHydrate,\n\toptions,\n\ttoChildArray,\n\tComponent\n} from 'preact';\n\nexport const REACT_ELEMENT_TYPE =\n\t(typeof Symbol != 'undefined' && Symbol.for && Symbol.for('react.element')) ||\n\t0xeac7;\n\nconst CAMEL_PROPS = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;\n\nconst IS_DOM = typeof document !== 'undefined';\n\n// Input types for which onchange should not be converted to oninput.\n// type=\"file|checkbox|radio\", plus \"range\" in IE11.\n// (IE11 doesn't support Symbol, which we use here to turn `rad` into `ra` which matches \"range\")\nconst onChangeInputType = type =>\n\t(typeof Symbol != 'undefined' && typeof Symbol() == 'symbol'\n\t\t? /fil|che|rad/i\n\t\t: /fil|che|ra/i\n\t).test(type);\n\n// Some libraries like `react-virtualized` explicitly check for this.\nComponent.prototype.isReactComponent = {};\n\n// `UNSAFE_*` lifecycle hooks\n// Preact only ever invokes the unprefixed methods.\n// Here we provide a base \"fallback\" implementation that calls any defined UNSAFE_ prefixed method.\n// - If a component defines its own `componentDidMount()` (including via defineProperty), use that.\n// - If a component defines `UNSAFE_componentDidMount()`, `componentDidMount` is the alias getter/setter.\n// - If anything assigns to an `UNSAFE_*` property, the assignment is forwarded to the unprefixed property.\n// See https://github.com/preactjs/preact/issues/1941\n[\n\t'componentWillMount',\n\t'componentWillReceiveProps',\n\t'componentWillUpdate'\n].forEach(key => {\n\tObject.defineProperty(Component.prototype, key, {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn this['UNSAFE_' + key];\n\t\t},\n\t\tset(v) {\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: v\n\t\t\t});\n\t\t}\n\t});\n});\n\n/**\n * Proxy render() since React returns a Component reference.\n * @param {import('./internal').VNode} vnode VNode tree to render\n * @param {import('./internal').PreactElement} parent DOM node to render vnode tree into\n * @param {() => void} [callback] Optional callback that will be called after rendering\n * @returns {import('./internal').Component | null} The root component reference or null\n */\nexport function render(vnode, parent, callback) {\n\t// React destroys any existing DOM nodes, see #1727\n\t// ...but only on the first render, see #1828\n\tif (parent._children == null) {\n\t\tparent.textContent = '';\n\t}\n\n\tpreactRender(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nexport function hydrate(vnode, parent, callback) {\n\tpreactHydrate(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nlet oldEventHook = options.event;\noptions.event = e => {\n\tif (oldEventHook) e = oldEventHook(e);\n\te.persist = empty;\n\te.isPropagationStopped = isPropagationStopped;\n\te.isDefaultPrevented = isDefaultPrevented;\n\treturn (e.nativeEvent = e);\n};\n\nfunction empty() {}\n\nfunction isPropagationStopped() {\n\treturn this.cancelBubble;\n}\n\nfunction isDefaultPrevented() {\n\treturn this.defaultPrevented;\n}\n\nlet classNameDescriptor = {\n\tconfigurable: true,\n\tget() {\n\t\treturn this.class;\n\t}\n};\n\nlet oldVNodeHook = options.vnode;\noptions.vnode = vnode => {\n\tlet type = vnode.type;\n\tlet props = vnode.props;\n\tlet normalizedProps = props;\n\n\t// only normalize props on Element nodes\n\tif (typeof type === 'string') {\n\t\tconst nonCustomElement = type.indexOf('-') === -1;\n\t\tnormalizedProps = {};\n\n\t\tfor (let i in props) {\n\t\t\tlet value = props[i];\n\n\t\t\tif (IS_DOM && i === 'children' && type === 'noscript') {\n\t\t\t\t// Emulate React's behavior of not rendering the contents of noscript tags on the client.\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (i === 'value' && 'defaultValue' in props && value == null) {\n\t\t\t\t// Skip applying value if it is null/undefined and we already set\n\t\t\t\t// a default value\n\t\t\t\tcontinue;\n\t\t\t} else if (\n\t\t\t\ti === 'defaultValue' &&\n\t\t\t\t'value' in props &&\n\t\t\t\tprops.value == null\n\t\t\t) {\n\t\t\t\t// `defaultValue` is treated as a fallback `value` when a value prop is present but null/undefined.\n\t\t\t\t// `defaultValue` for Elements with no value prop is the same as the DOM defaultValue property.\n\t\t\t\ti = 'value';\n\t\t\t} else if (i === 'download' && value === true) {\n\t\t\t\t// Calling `setAttribute` with a truthy value will lead to it being\n\t\t\t\t// passed as a stringified value, e.g. `download=\"true\"`. React\n\t\t\t\t// converts it to an empty string instead, otherwise the attribute\n\t\t\t\t// value will be used as the file name and the file will be called\n\t\t\t\t// \"true\" upon downloading it.\n\t\t\t\tvalue = '';\n\t\t\t} else if (/ondoubleclick/i.test(i)) {\n\t\t\t\ti = 'ondblclick';\n\t\t\t} else if (\n\t\t\t\t/^onchange(textarea|input)/i.test(i + type) &&\n\t\t\t\t!onChangeInputType(props.type)\n\t\t\t) {\n\t\t\t\ti = 'oninput';\n\t\t\t} else if (/^on(Ani|Tra|Tou|BeforeInp)/.test(i)) {\n\t\t\t\ti = i.toLowerCase();\n\t\t\t} else if (nonCustomElement && CAMEL_PROPS.test(i)) {\n\t\t\t\ti = i.replace(/[A-Z0-9]/, '-$&').toLowerCase();\n\t\t\t} else if (value === null) {\n\t\t\t\tvalue = undefined;\n\t\t\t}\n\n\t\t\tnormalizedProps[i] = value;\n\t\t}\n\n\t\t// Add support for array select values: <select multiple value={[]} />\n\t\tif (\n\t\t\ttype == 'select' &&\n\t\t\tnormalizedProps.multiple &&\n\t\t\tArray.isArray(normalizedProps.value)\n\t\t) {\n\t\t\t// forEach() always returns undefined, which we abuse here to unset the value prop.\n\t\t\tnormalizedProps.value = toChildArray(props.children).forEach(child => {\n\t\t\t\tchild.props.selected =\n\t\t\t\t\tnormalizedProps.value.indexOf(child.props.value) != -1;\n\t\t\t});\n\t\t}\n\n\t\t// Adding support for defaultValue in select tag\n\t\tif (type == 'select' && normalizedProps.defaultValue != null) {\n\t\t\tnormalizedProps.value = toChildArray(props.children).forEach(child => {\n\t\t\t\tif (normalizedProps.multiple) {\n\t\t\t\t\tchild.props.selected =\n\t\t\t\t\t\tnormalizedProps.defaultValue.indexOf(child.props.value) != -1;\n\t\t\t\t} else {\n\t\t\t\t\tchild.props.selected =\n\t\t\t\t\t\tnormalizedProps.defaultValue == child.props.value;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tvnode.props = normalizedProps;\n\t}\n\n\tif (type && props.class != props.className) {\n\t\tclassNameDescriptor.enumerable = 'className' in props;\n\t\tif (props.className != null) normalizedProps.class = props.className;\n\t\tObject.defineProperty(normalizedProps, 'className', classNameDescriptor);\n\t}\n\n\tvnode.$$typeof = REACT_ELEMENT_TYPE;\n\n\tif (oldVNodeHook) oldVNodeHook(vnode);\n};\n\n// Only needed for react-relay\nlet currentComponent;\nconst oldBeforeRender = options._render;\noptions._render = function(vnode) {\n\tif (oldBeforeRender) {\n\t\toldBeforeRender(vnode);\n\t}\n\tcurrentComponent = vnode._component;\n};\n\n// This is a very very private internal function for React it\n// is used to sort-of do runtime dependency injection. So far\n// only `react-relay` makes use of it. It uses it to read the\n// context value.\nexport const __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {\n\tReactCurrentDispatcher: {\n\t\tcurrent: {\n\t\t\treadContext(context) {\n\t\t\t\treturn currentComponent._globalContext[context._id].props.value;\n\t\t\t}\n\t\t}\n\t}\n};\n", "import {\n\tcreateElement,\n\trender as preactRender,\n\tcloneElement as preactCloneElement,\n\tcreateRef,\n\tComponent,\n\tcreateContext,\n\tFragment\n} from 'preact';\nimport {\n\tuseState,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue\n} from 'preact/hooks';\nimport { PureComponent } from './PureComponent';\nimport { memo } from './memo';\nimport { forwardRef } from './forwardRef';\nimport { Children } from './Children';\nimport { Suspense, lazy } from './suspense';\nimport { SuspenseList } from './suspense-list';\nimport { createPortal } from './portals';\nimport {\n\thydrate,\n\trender,\n\tREACT_ELEMENT_TYPE,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n} from './render';\n\nconst version = '17.0.2'; // trick libraries to think we are react\n\n/**\n * Legacy version of createElement.\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component constructor\n */\nfunction createFactory(type) {\n\treturn createElement.bind(null, type);\n}\n\n/**\n * Check if the passed element is a valid (p)react node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isValidElement(element) {\n\treturn !!element && element.$$typeof === REACT_ELEMENT_TYPE;\n}\n\n/**\n * Wrap `cloneElement` to abort if the passed element is not a valid element and apply\n * all vnode normalizations.\n * @param {import('./internal').VNode} element The vnode to clone\n * @param {object} props Props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Optional component children\n */\nfunction cloneElement(element) {\n\tif (!isValidElement(element)) return element;\n\treturn preactCloneElement.apply(null, arguments);\n}\n\n/**\n * Remove a component tree from the DOM, including state and event handlers.\n * @param {import('./internal').PreactElement} container\n * @returns {boolean}\n */\nfunction unmountComponentAtNode(container) {\n\tif (container._children) {\n\t\tpreactRender(null, container);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**\n * Get the matching DOM node for a component\n * @param {import('./internal').Component} component\n * @returns {import('./internal').PreactElement | null}\n */\nfunction findDOMNode(component) {\n\treturn (\n\t\t(component &&\n\t\t\t(component.base || (component.nodeType === 1 && component))) ||\n\t\tnull\n\t);\n}\n\n/**\n * Deprecated way to control batched rendering inside the reconciler, but we\n * already schedule in batches inside our rendering code\n * @template Arg\n * @param {(arg: Arg) => void} callback function that triggers the updated\n * @param {Arg} [arg] Optional argument that can be passed to the callback\n */\n// eslint-disable-next-line camelcase\nconst unstable_batchedUpdates = (callback, arg) => callback(arg);\n\n/**\n * In React, `flushSync` flushes the entire tree and forces a rerender. It's\n * implmented here as a no-op.\n * @template Arg\n * @template Result\n * @param {(arg: Arg) => Result} callback function that runs before the flush\n * @param {Arg} [arg] Optional arugment that can be passed to the callback\n * @returns\n */\nconst flushSync = (callback, arg) => callback(arg);\n\n/**\n * Strict Mode is not implemented in Preact, so we provide a stand-in for it\n * that just renders its children without imposing any restrictions.\n */\nconst StrictMode = Fragment;\n\nexport * from 'preact/hooks';\nexport {\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\tflushSync,\n\t// eslint-disable-next-line camelcase\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n\n// React copies the named exports to the default one.\nexport default {\n\tuseState,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue,\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\tflushSync,\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n", "import { h } from 'preact';\r\nimport { memo } from 'preact/compat';\r\nimport { useEffect } from 'preact/hooks';\r\n\r\n// utils\r\nimport { getCanvasContext } from '@utils/canvas.utils';\r\n\r\n// types\r\nimport { ICanvasPureComponent } from './Canvas.types';\r\n\r\n// pure/functional component for canvas initalization without re-rendering\r\nexport const Canvas = memo(\r\n    ({ id, canvasRef, height, width, events }: ICanvasPureComponent) => {\r\n        // on canvas load\r\n        useEffect(() => {\r\n            const { ctx } = getCanvasContext(canvasRef);\r\n            console.log('[canvas]: mounted', id);\r\n\r\n            // fix anti-aliasing\r\n            ctx.translate(0.5, 0.5);\r\n            ctx.translate(-0.5, -0.5);\r\n\r\n            // callback\r\n            if (events?.onLoad) events.onLoad();\r\n        });\r\n\r\n        return (\r\n            <canvas\r\n                id={id}\r\n                tabIndex={0}\r\n                height={height}\r\n                width={width}\r\n                ref={canvasRef}\r\n                {...events}\r\n            />\r\n        );\r\n    },\r\n    (prev, next) => {\r\n        // memo only makes a shallow comparison of objects\r\n        // hence 'onMouseMove' function will trigger a re-render everytime\r\n        // but we're not sending in any dynamic changes hence a constant return\r\n        return true;\r\n    }\r\n);\r\n", "import { Ref } from 'preact/hooks';\r\n\r\n// utils\r\nimport { getCanvasContext } from '@utils/canvas.utils';\r\n\r\n// types\r\nimport { IMarketItem } from 'src/types/data.types';\r\nimport { clamp } from '@utils/math.utils';\r\n\r\n/**\r\n * draw min/max at their corresponding tick\r\n * @param ref\r\n * @param min non-ipl min\r\n * @param max non-ipl max\r\n * @param ipl\r\n */\r\nexport const onDrawMinMax = (\r\n    ref: Ref<HTMLCanvasElement>,\r\n    min: IMarketItem,\r\n    max: IMarketItem,\r\n    ipl: Record<number, IMarketItem>\r\n) => {\r\n    const { canvas, ctx } = getCanvasContext(ref);\r\n\r\n    // min, max for non-interpolated items\r\n    [min, max].forEach((item, i) => {\r\n        const isMax = i > 0;\r\n        const fit = ipl[item.index];\r\n\r\n        const price = isMax ? item.spark.high : item.spark.low;\r\n        const priceStr = Math.round(price).toString();\r\n        const { width: textWidth } = ctx.measureText(priceStr);\r\n\r\n        const padX = 5;\r\n        const padY = canvas.height * 0.1;\r\n\r\n        let x = fit.openTime;\r\n        x = clamp(x, padX, canvas.width - textWidth - padX);\r\n\r\n        let y = fit.spark.close;\r\n        y = clamp(isMax ? y + padY : y - padY, 5, canvas.height);\r\n\r\n        ctx.fillStyle = '#fff';\r\n        ctx.font = '12px Hack, monospace';\r\n\r\n        // use clamp for 0 + 5 to end - 5, for both x and y\r\n        ctx.fillText(Math.round(price).toString(), x, y);\r\n    });\r\n};\r\n", "const colorMap = {} as Record<string, string>;\r\n\r\n/**\r\n * load css variable color\r\n * @param name\r\n * @returns\r\n */\r\nexport const getCssColor = (name: string) => {\r\n    if (colorMap[name]) return colorMap[name];\r\n\r\n    colorMap[name] = window\r\n        .getComputedStyle(document.body)\r\n        .getPropertyValue(name);\r\n\r\n    return colorMap[name];\r\n};\r\n", "import { Ref } from 'preact/hooks';\r\n\r\n// utils\r\nimport { getCanvasContext, lineY } from '@utils/canvas.utils';\r\nimport { getCssColor } from '@utils/color.utils';\r\n\r\n// types\r\nimport { IChartState } from '../MarketGraph.types';\r\n\r\n/**\r\n * draw box with mousedown/mouseup\r\n * @param ref\r\n * @param state\r\n * @param moveX\r\n * @param moveY\r\n */\r\nexport const onDrawTrendBox = (\r\n    ref: Ref<HTMLCanvasElement>,\r\n    state: IChartState,\r\n    moveX: number,\r\n    moveY: number\r\n) => {\r\n    const { ctx } = getCanvasContext(ref);\r\n\r\n    const clrLongRGBA20 = getCssColor('--clr-rgba-long-20');\r\n    const clrShortRGBA20 = getCssColor('--clr-rgba-short-20');\r\n\r\n    const drawCircle = (x: number, y: number) => {\r\n        ctx.beginPath();\r\n        ctx.strokeStyle = '#cecece';\r\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\r\n        ctx.stroke();\r\n    };\r\n\r\n    const { drawActive, drawHistory } = state;\r\n    for (const box of [drawActive, ...drawHistory]) {\r\n        if (box.hidden || !box.start) continue;\r\n\r\n        const { active, start, end } = box;\r\n        const [x0, y0] = [lineY(start.x), lineY(start.y)];\r\n        const [x1, y1] = [lineY(end.x), lineY(end.y)];\r\n\r\n        drawCircle(x0, y0);\r\n        drawCircle(x1, y1);\r\n\r\n        // draw, mousedown\r\n        if (active) {\r\n            const [w, h] = [moveX - x0, moveY - y0];\r\n            ctx.fillStyle = h < 0 ? clrLongRGBA20 : clrShortRGBA20;\r\n            ctx.fillRect(x0, y0, w, h);\r\n        }\r\n\r\n        // end, mouseup\r\n        else if (!active) {\r\n            const [w, h] = [x0 - x1, y0 - y1];\r\n            ctx.fillStyle = h > 0 ? clrLongRGBA20 : clrShortRGBA20;\r\n            ctx.fillRect(x1, y1, w, h);\r\n        }\r\n    }\r\n};\r\n", "import { Ref } from 'preact/hooks';\r\n\r\n// utils\r\nimport { getCanvasContext, lineY } from '@utils/canvas.utils';\r\nimport { getCssColor } from '@utils/color.utils';\r\n\r\n// types\r\nimport { IMarketItem } from 'src/types/data.types';\r\n\r\n/**\r\n * draw crosshair around hovered interpolated item (snaps to X)\r\n * @param ref\r\n * @param iplHover\r\n * @param moveY\r\n */\r\nexport const onDrawCross = (\r\n    ref: Ref<HTMLCanvasElement>,\r\n    iplHover: IMarketItem,\r\n    moveY: number\r\n) => {\r\n    if (moveY == 0) return;\r\n\r\n    const { canvas, ctx } = getCanvasContext(ref);\r\n    const { height, width } = canvas;\r\n\r\n    const clrTextBg40 = getCssColor('--clr-text-bg-40');\r\n\r\n    // crosshair jumps and snaps between each X bar\r\n    const x = iplHover.openTime;\r\n    const y = lineY(moveY);\r\n\r\n    ctx.beginPath();\r\n\r\n    // mid-bot\r\n    ctx.moveTo(x, y);\r\n    ctx.lineTo(x, lineY(height));\r\n\r\n    // mid-left\r\n    ctx.moveTo(x, y);\r\n    ctx.lineTo(0, y);\r\n\r\n    // mid-top\r\n    ctx.moveTo(x, y);\r\n    ctx.lineTo(x, 0);\r\n\r\n    // mid-right\r\n    ctx.moveTo(x, y);\r\n    ctx.lineTo(width, y);\r\n\r\n    ctx.strokeStyle = clrTextBg40;\r\n    ctx.lineWidth = 1;\r\n    ctx.stroke();\r\n};\r\n", "import { Ref } from 'preact/hooks';\r\n\r\n// utils\r\nimport { getCanvasContext, lineY } from '@utils/canvas.utils';\r\nimport { getCssColor } from '@utils/color.utils';\r\nimport { lerp } from '@utils/math.utils';\r\n\r\n// types\r\nimport { IMarketItem } from 'src/types/data.types';\r\n\r\n/**\r\n * static drawing behind composite\r\n * @param ctx\r\n * @param items\r\n * @param interpolate\r\n */\r\nexport const onDrawGrid = (ref: Ref<HTMLCanvasElement>, ipl: IMarketItem[]) => {\r\n    const { canvas, ctx } = getCanvasContext(ref);\r\n    const clrGuide = getCssColor('--clr-guide');\r\n\r\n    // X grid on every 3rd tick\r\n    const drawGridX = () => {\r\n        for (let i = 0; i < ipl.length; i++) {\r\n            // draw mode behind\r\n            ctx.globalCompositeOperation = 'destination-over';\r\n            ctx.setLineDash([2, 2]);\r\n\r\n            // every 5th tick\r\n            if (i !== 0 && i % 5 !== 0) continue;\r\n            const { openTime: x } = ipl[i];\r\n\r\n            // X: draw horizontal lines on each N'th tick\r\n            ctx.beginPath();\r\n\r\n            ctx.moveTo(x, 0);\r\n            ctx.lineTo(x, lineY(canvas.height));\r\n\r\n            ctx.lineWidth = 1;\r\n            ctx.strokeStyle = clrGuide;\r\n            ctx.stroke();\r\n\r\n            // draw mode front\r\n            ctx.globalCompositeOperation = 'source-over';\r\n            ctx.setLineDash([0, 0]);\r\n        }\r\n    };\r\n\r\n    // Y on every 10% of the price\r\n    const drawGridY = () => {\r\n        for (let i = 1; i <= 10; i++) {\r\n            const y = lerp(1, canvas.height - 1, i / 10);\r\n\r\n            ctx.globalCompositeOperation = 'destination-over';\r\n            ctx.setLineDash([2, 2]);\r\n\r\n            // draw\r\n            ctx.beginPath();\r\n\r\n            ctx.moveTo(0, y);\r\n            ctx.lineTo(canvas.width, lineY(y));\r\n\r\n            ctx.lineWidth = 1;\r\n            ctx.strokeStyle = clrGuide;\r\n            ctx.stroke();\r\n\r\n            // stroke behind composite\r\n            ctx.globalCompositeOperation = 'source-over';\r\n            ctx.setLineDash([0, 0]);\r\n        }\r\n    };\r\n\r\n    drawGridX();\r\n    drawGridY();\r\n};\r\n", "import { Ref } from 'preact/hooks';\r\n\r\n// utils\r\nimport { getCanvasContext } from '@utils/canvas.utils';\r\nimport { getCssColor } from '@utils/color.utils';\r\n\r\n// types\r\nimport { IMarketItem, IMarketSpark } from 'src/types/data.types';\r\n\r\nexport const onDrawInfo = (ref: Ref<HTMLCanvasElement>, hover: IMarketItem) => {\r\n    // if (moveX == 0 && moveY == 0) return;\r\n    const { ctx } = getCanvasContext(ref);\r\n\r\n    const clrTextWeak = getCssColor('--clr-textWeak');\r\n    const clrTextStrong = getCssColor('--clr-textStrong');\r\n\r\n    // time of tick\r\n    const drawTime = () => {\r\n        const ts = new Date(hover.openTime).toLocaleString('en-GB', {\r\n            year: 'numeric',\r\n            month: '2-digit',\r\n            day: '2-digit',\r\n            hour: '2-digit',\r\n            minute: '2-digit'\r\n        });\r\n\r\n        const { width } = ctx.measureText(ts);\r\n\r\n        ctx.fillStyle = '#cecece';\r\n        ctx.font = '12px Hack, monospace';\r\n        ctx.fillText(ts, 0, 20);\r\n\r\n        return width;\r\n    };\r\n    const timeWidth = drawTime();\r\n\r\n    // ohlc bar info\r\n    const drawInfoBar = () => {\r\n        ctx.font = '12px Hack, monospace';\r\n        let infoWidth = 0;\r\n\r\n        // pad N px from time\r\n        Object.keys(hover.spark).forEach(k => {\r\n            const key = k as keyof IMarketSpark;\r\n            const prefix = k[0].toUpperCase();\r\n\r\n            const value = Math.round(hover.spark[key]).toString();\r\n            const line = prefix + value;\r\n\r\n            infoWidth += ctx.measureText(line).width + 15;\r\n\r\n            ctx.fillStyle = clrTextWeak;\r\n            ctx.fillText(prefix, infoWidth + timeWidth, 20);\r\n\r\n            ctx.fillStyle = clrTextStrong;\r\n            ctx.fillText(value, infoWidth + timeWidth + 10, 20);\r\n        });\r\n    };\r\n    drawInfoBar();\r\n};\r\n", "import { Ref } from 'preact/hooks';\r\n\r\n// utils\r\nimport { getCanvasContext } from '@utils/canvas.utils';\r\nimport { getCssColor } from '@utils/color.utils';\r\n\r\n// types\r\nimport { IMarketItem } from 'src/types/data.types';\r\n\r\n/**\r\n * draw percentage change between each tick\r\n * @param items\r\n * @param itemHover\r\n */\r\nexport const onDrawPChange = (\r\n    ref: Ref<HTMLCanvasElement>,\r\n    items: IMarketItem[],\r\n    itemHover: IMarketItem\r\n) => {\r\n    const { ctx } = getCanvasContext(ref);\r\n    const clrTextStrong = getCssColor('--clr-textStrong');\r\n\r\n    let last = items.indexOf(itemHover);\r\n    last = last == 0 ? items.length - 1 : last - 1;\r\n\r\n    const lastClose = items[last].spark.close;\r\n    const thisClose = itemHover.spark.close;\r\n\r\n    const change = (thisClose - lastClose) / thisClose;\r\n    const format = (change * 100).toFixed(3).padStart(6, '+') + '%';\r\n\r\n    ctx.fillStyle = clrTextStrong;\r\n    ctx.fillText(format, 100 * 5, 20);\r\n};\r\n", "import { Ref } from 'preact/hooks';\r\n\r\n// components\r\nimport { onDrawMinMax } from '../analytics/onDrawMinMax';\r\nimport { onDrawTrendBox as onDrawTrendBox } from '../analytics/onDrawTrendBox';\r\nimport { onDrawCross } from '../info/onDrawCross';\r\nimport { onDrawGrid } from '../info/onDrawGrid';\r\nimport { onDrawInfo } from '../info/onDrawInfo';\r\nimport { onDrawPChange } from '../info/onDrawPChange';\r\n\r\n// utils\r\nimport { getCanvasContext } from '@utils/canvas.utils';\r\nimport { getCssColor } from '@utils/color.utils';\r\nimport { getHoverMarket, getIplMarket } from '@utils/data.utils';\r\n\r\n// types\r\nimport { IMarketItem } from 'src/types/data.types';\r\nimport { IChartState } from '../MarketGraph.types';\r\n\r\nexport const onDrawCandle = (\r\n    ref: Ref<HTMLCanvasElement>,\r\n    state: IChartState,\r\n    items: IMarketItem[],\r\n\r\n    moveX: number = 0,\r\n    moveY: number = 0\r\n) => {\r\n    const { canvas, ctx } = getCanvasContext(ref);\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n    const clrShort = getCssColor('--clr-short');\r\n    const clrLong = getCssColor('--clr-long');\r\n\r\n    // interpolate items to fit canvas frame\r\n    const { ipl, minX, maxX } = getIplMarket(\r\n        canvas.height,\r\n        canvas.width,\r\n        items\r\n    );\r\n\r\n    // keep reference of ids\r\n    const iplMap = {} as Record<number, IMarketItem>;\r\n    ipl.forEach(k => (iplMap[k.index] = k));\r\n\r\n    // draw analytics\r\n    onDrawTrendBox(ref, state, moveX, moveY);\r\n    onDrawMinMax(ref, minX, maxX, iplMap);\r\n\r\n    //\r\n    const drawCandle = (item: IMarketItem) => {\r\n        const { openTime: x } = item;\r\n        const { open, high, low, close } = item.spark;\r\n        ctx.strokeStyle = open < close ? clrShort : clrLong;\r\n\r\n        // thin H/L\r\n        ctx.beginPath();\r\n\r\n        ctx.moveTo(x, high);\r\n        ctx.lineTo(x, low);\r\n\r\n        ctx.lineWidth = 1;\r\n        ctx.stroke();\r\n\r\n        // thick O/C\r\n        ctx.beginPath();\r\n\r\n        ctx.moveTo(x, open);\r\n        ctx.lineTo(x, close);\r\n\r\n        ctx.lineWidth = 5;\r\n        ctx.stroke();\r\n    };\r\n\r\n    for (let i = 0; i < ipl.length; i++) {\r\n        // draw\r\n        drawCandle(ipl[i]);\r\n    }\r\n\r\n    const { iplHover, itemHover } = getHoverMarket(moveX, ipl, items);\r\n\r\n    onDrawCross(ref, iplHover, moveY);\r\n    onDrawInfo(ref, itemHover);\r\n\r\n    onDrawGrid(ref, ipl);\r\n    onDrawPChange(ref, items, itemHover);\r\n};\r\n", "import { h } from 'preact';\r\nimport { useMemo, useRef } from 'preact/hooks';\r\n\r\n// components\r\nimport { Canvas } from '@components/Canvas/Canvas';\r\nimport { onDrawCandle } from './graphs/onDrawCandle';\r\n\r\n// utils\r\nimport { getCanvasContext, getCanvasPos } from '@utils/canvas.utils';\r\n\r\n// types\r\nimport { ICanvasEvents } from '../Canvas/Canvas.types';\r\nimport { ICanvasDraw, IChartState } from './MarketGraph.types';\r\nimport { IMarketItem } from 'src/types/data.types';\r\n\r\nexport interface IMarketChartProps {\r\n    items: IMarketItem[];\r\n}\r\n\r\nexport const MarketChart = ({ items }: IMarketChartProps) => {\r\n    const ref = useRef({} as HTMLCanvasElement);\r\n\r\n    const state: IChartState = {\r\n        drawHistory: [] as ICanvasDraw[],\r\n        drawActive: {} as ICanvasDraw,\r\n\r\n        history: 0,\r\n        zoom: 0\r\n    };\r\n\r\n    const drawChart = (x: number = 0, y: number = 0) => {\r\n        onDrawCandle(ref, state, items.slice(state.zoom), x, y);\r\n    };\r\n\r\n    const events: ICanvasEvents = {\r\n        onLoad: function () {\r\n            drawChart();\r\n        },\r\n\r\n        onMouseMove: function (e: MouseEvent) {\r\n            const { canvas } = getCanvasContext(ref);\r\n            const { x, y } = getCanvasPos(canvas, e);\r\n\r\n            drawChart(x, y);\r\n        },\r\n\r\n        onMouseDown: function (e: MouseEvent) {\r\n            const { canvas } = getCanvasContext(ref);\r\n            const { x, y } = getCanvasPos(canvas, e);\r\n\r\n            state.drawActive = {\r\n                ...state.drawActive,\r\n                active: true,\r\n                hidden: false,\r\n                start: { x, y },\r\n                end: { x: 0, y: 0 }\r\n            };\r\n        },\r\n\r\n        onMouseUp: function (e: MouseEvent) {\r\n            const { canvas } = getCanvasContext(ref);\r\n            const { x, y } = getCanvasPos(canvas, e);\r\n\r\n            state.drawActive = {\r\n                ...state.drawActive,\r\n                active: false,\r\n                end: { x, y }\r\n            };\r\n\r\n            state.drawHistory.push(state.drawActive);\r\n            state.history = state.drawHistory.length - 1;\r\n        },\r\n\r\n        onWheel: function (e: WheelEvent) {\r\n            e.preventDefault();\r\n\r\n            const speed = 2;\r\n            state.zoom += e.deltaY < 0 ? speed : -speed;\r\n\r\n            const min = 0;\r\n            const max = items.length - 5;\r\n\r\n            // sanity check\r\n            if (state.zoom < min) state.zoom = min;\r\n            else if (state.zoom > max) state.zoom = max;\r\n\r\n            drawChart();\r\n        },\r\n\r\n        onKeyDown: function (e: KeyboardEvent) {\r\n            if (!e.ctrlKey) return;\r\n\r\n            const { history } = state;\r\n            const max = state.drawHistory.length - 1;\r\n\r\n            switch (e.key) {\r\n                case 'z':\r\n                    if (history >= 0) {\r\n                        state.drawHistory[state.history--].hidden = true;\r\n                        state.history = history == 0 ? 0 : history - 1;\r\n                    }\r\n                    break;\r\n\r\n                case 'y':\r\n                    if (history <= max) {\r\n                        state.drawHistory[state.history++].hidden = false;\r\n                        state.history = history == max ? max : history + 1;\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            drawChart();\r\n        }\r\n    };\r\n\r\n    // pure event handler\r\n    const eventsMemo = useMemo(() => events, []);\r\n\r\n    return (\r\n        <Canvas\r\n            id=\"candle-chart\"\r\n            height={300}\r\n            width={600}\r\n            canvasRef={ref}\r\n            events={eventsMemo}\r\n        />\r\n    );\r\n};\r\n", "import { IOrderBookItem } from './OrderBook.types';\r\n\r\n/**\r\n * process and group entries\r\n * @param items items sorted by price\r\n * @param midPoint or lastTradedPrice\r\n */\r\nexport const setOrderBookInfo = (items: IOrderBookItem[], midPoint: number) => {\r\n    // TODO: add grouping\r\n    const processed = [] as IOrderBookItem[];\r\n\r\n    let lastPrice = 0;\r\n    let totalPrice = 0;\r\n    let totalVolume = 0;\r\n\r\n    for (let i = 0; i < items.length; i++) {\r\n        let { price, volume, long } = items[i];\r\n\r\n        //\r\n        totalPrice += price;\r\n        totalVolume += volume;\r\n\r\n        // last and current price\r\n        const lp = lastPrice.toFixed(1).split('');\r\n        const cp = price.toFixed(1).split('');\r\n\r\n        // get index to start highlighting\r\n        let hlight = 0;\r\n        for (let i = 0; i < cp.length; i++) {\r\n            if (lp[i] !== cp[i]) {\r\n                hlight = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // percentage difference from last traded price\r\n        const percent = Math.abs((midPoint - totalPrice) / midPoint);\r\n\r\n        processed.push({\r\n            price,\r\n            volume,\r\n            totalPercent: Number(percent.toFixed(8)),\r\n            totalVolume,\r\n            long,\r\n            mirrored: 0,\r\n            // TODO: decide significant dynamically\r\n            significant: volume > 0.15 ?? false,\r\n            hlight,\r\n            index: i\r\n        });\r\n\r\n        // update price for next iteration\r\n        lastPrice = price;\r\n    }\r\n\r\n    return processed;\r\n};\r\n\r\n/**\r\n * match mirrored entry between 'asks' and 'bids' by 'totalPercent' from 'midPoint'\r\n * @param asks\r\n * @param bids\r\n */\r\nexport const setMirrored = (asks: IOrderBookItem[], bids: IOrderBookItem[]) => {\r\n    for (let i = 0; i < asks.length; i++) {\r\n        const a = asks[i];\r\n        for (let j = 0; j < bids.length; j++) {\r\n            const b = bids[i];\r\n            if (a.totalPercent >= b.totalPercent) {\r\n                a.mirrored = b.price;\r\n                b.mirrored = a.price;\r\n            }\r\n        }\r\n    }\r\n};\r\n", "export interface IOrderBookItem {\r\n    price: number;\r\n    volume: number;\r\n    long: boolean;\r\n\r\n    /**\r\n     * percentage from midpoint (or last traded price)\r\n     * used as Y-axis\r\n     */\r\n    totalPercent: number;\r\n\r\n    /**\r\n     * sum of all volumes from midpoint\r\n     * used as X-axis\r\n     */\r\n    totalVolume: number;\r\n\r\n    /**\r\n     * opposite IOrderBookItem index e.g in bids if asks\r\n     */\r\n    mirrored: number;\r\n\r\n    /**\r\n     * is point singificant / resistence\r\n     */\r\n    significant: boolean;\r\n\r\n    /**\r\n     * index of start text highlighting on\r\n     */\r\n    hlight: number;\r\n\r\n    /**\r\n     * index in list\r\n     */\r\n    index: number;\r\n}\r\n\r\nexport interface IOrderBook {\r\n    asks: IOrderBookItem[];\r\n    bids: IOrderBookItem[];\r\n}\r\n\r\nexport interface IOrderBookState {\r\n    sender: EOrderBookSender;\r\n    book: IOrderBook;\r\n    hover: IOrderBookItem;\r\n    mirrored: number;\r\n}\r\n\r\n// actions\r\nexport enum EOrderBookAction {\r\n    None,\r\n    AddOrderBook,\r\n    HoverEntry\r\n}\r\n\r\n// dispatcher\r\nexport enum EOrderBookSender {\r\n    BookAsks,\r\n    BookBids,\r\n    GraphAsks,\r\n    GraphBids\r\n}\r\n\r\n// discriminated union type\r\nexport type TOrderBookAction =\r\n    | {\r\n          cmd: EOrderBookAction.AddOrderBook;\r\n          sender: EOrderBookSender;\r\n          book: IOrderBook;\r\n      }\r\n    | {\r\n          cmd: EOrderBookAction.HoverEntry;\r\n          sender: EOrderBookSender;\r\n          hover: IOrderBookItem;\r\n      };\r\n\r\n// state\r\nexport interface IDepthState {\r\n    sender: EOrderBookSender;\r\n    hover: IOrderBookItem;\r\n    depth: IOrderBook;\r\n}\r\n", "import {\r\n    EOrderBookAction,\r\n    IOrderBookState,\r\n    TOrderBookAction\r\n} from './OrderBook.types';\r\n\r\n/**\r\n * updates any component listening to this reducer\r\n * do not mutate the state directly\r\n */\r\nexport const orderBookReducer = (\r\n    state: IOrderBookState,\r\n    action: TOrderBookAction\r\n): IOrderBookState => {\r\n    const { sender } = action;\r\n\r\n    switch (action.cmd) {\r\n        case EOrderBookAction.HoverEntry:\r\n            const { hover } = action;\r\n            return { ...state, sender, hover };\r\n\r\n        case EOrderBookAction.AddOrderBook:\r\n            const { book } = action;\r\n            return { ...state, sender, book };\r\n    }\r\n};\r\n", "import { createContext, h } from 'preact';\r\nimport { useContext, useReducer } from 'preact/hooks';\r\n\r\n// actions\r\nimport { orderBookReducer } from './OrderBook.reducer';\r\n\r\n// types\r\nimport { IDispatch } from 'src/types/hook.types';\r\nimport { IOrderBookState, TOrderBookAction } from './OrderBook.types';\r\n\r\n/**\r\n * context of dispatcher for store to use\r\n */\r\nconst OrderBookContext = createContext(\r\n    {} as IDispatch<IOrderBookState, TOrderBookAction>\r\n);\r\n\r\nconst orderBookState = {\r\n    book: {},\r\n    hover: {}\r\n} as IOrderBookState;\r\n\r\n/**\r\n * store allows 'value' to be automatically inherited by any child component\r\n * @returns\r\n */\r\nexport const OrderBookStore = ({ children }: any) => {\r\n    const [state, dispatch] = useReducer(orderBookReducer, orderBookState);\r\n\r\n    const value = { state, dispatch } as IDispatch<\r\n        IOrderBookState,\r\n        TOrderBookAction\r\n    >;\r\n\r\n    return (\r\n        <OrderBookContext.Provider value={value}>\r\n            {children}\r\n        </OrderBookContext.Provider>\r\n    );\r\n};\r\n\r\n/**\r\n * the 'useState' of our store\r\n * @returns\r\n */\r\nexport const useOrderBook = () => {\r\n    const context = useContext(OrderBookContext);\r\n    if (context === undefined) {\r\n        throw new Error('useOrderBook must be used within <OrderBookStore>');\r\n    }\r\n    return context;\r\n};\r\n", "import { useMemo } from 'preact/hooks';\r\n\r\n// actions\r\nimport { useOrderBook } from './OrderBook.store';\r\n\r\n// types\r\nimport {\r\n    EOrderBookAction,\r\n    EOrderBookSender,\r\n    IOrderBookItem\r\n} from './OrderBook.types';\r\n\r\nexport const useHover = (sender: EOrderBookSender, item: IOrderBookItem) => {\r\n    const { dispatch } = useOrderBook();\r\n\r\n    const events = useMemo(\r\n        () => ({\r\n            onMouseOver() {\r\n                dispatch({\r\n                    cmd: EOrderBookAction.HoverEntry,\r\n                    sender,\r\n                    hover: item\r\n                });\r\n            }\r\n        }),\r\n        []\r\n    );\r\n\r\n    return events;\r\n};\r\n", "import { h } from 'preact';\r\n\r\n// utils\r\nimport { setMirrored, setOrderBookInfo } from './OrderBook.utils';\r\n\r\n// actions\r\nimport { useHover } from './OrderBook.actions';\r\nimport { useOrderBook } from './OrderBook.store';\r\n\r\n// types\r\nimport {\r\n    EOrderBookSender,\r\n    IOrderBook,\r\n    IOrderBookItem\r\n} from './OrderBook.types';\r\n\r\n// styles\r\nimport './OrderBook.module.scss';\r\n\r\ninterface IOrderBookItemProps {\r\n    sender: EOrderBookSender;\r\n    item: IOrderBookItem;\r\n    hover: IOrderBookItem;\r\n}\r\n\r\nconst OrderBookItem = ({ sender, item, hover }: IOrderBookItemProps) => {\r\n    // set events for item\r\n    const events = useHover(sender, item);\r\n\r\n    //\r\n    const { price, volume, totalVolume, long, hlight, significant } = item;\r\n\r\n    // colors for highlight\r\n    const dim = `clr-${long ? 'long' : 'short'}-fill`;\r\n    const light = `clr-${long ? 'long' : 'short'}-highlight`;\r\n\r\n    // info\r\n    const p = price.toFixed(1).split('');\r\n    const v = volume.toFixed(4);\r\n    const tv = totalVolume.toFixed(4);\r\n\r\n    // is item our hovered item or it's mirrored opposite\r\n    const isHovered = (hover: IOrderBookItem, price: number) => {\r\n        if (!hover) return false;\r\n        return hover.price === price || hover.mirrored === price;\r\n    };\r\n    const hoverCls = isHovered(hover, price) ? 'order-list-entry--hover' : '';\r\n\r\n    // highlight 'significant' volume as 'resistence'\r\n    const sigCls = significant ? 'order-list-entry--significant' : '';\r\n\r\n    return (\r\n        <li {...events} className={`order-list-entry ${hoverCls} ${sigCls}`}>\r\n            <div className=\"order-list-entry-price\">\r\n                <span className={dim}>{p.slice(0, hlight).join('')}</span>\r\n                <span className={light}>{p.slice(hlight).join('')}</span>\r\n            </div>\r\n\r\n            <div className=\"order-list-entry-amount\">\r\n                <span className=\"clr-text-strong\">{v[0]}</span>\r\n                <span className=\"clr-text-weak\">{v.slice(1)}</span>\r\n            </div>\r\n\r\n            <div className=\"order-list-entry-total-amount\">\r\n                <span className=\"clr-text-weak\">{tv[0]}</span>\r\n                <span className=\"clr-text-strong\">{tv.slice(1)}</span>\r\n            </div>\r\n        </li>\r\n    );\r\n};\r\n\r\nexport const OrderBook = ({ asks, bids }: IOrderBook) => {\r\n    // state only updates (re-render) if a new value is inputted\r\n    const { state } = useOrderBook();\r\n\r\n    // sort by ascending or decending price\r\n    asks = asks.sort((a, b) => a.price - b.price);\r\n    bids = bids.sort((a, b) => b.price - a.price);\r\n\r\n    // current trading price\r\n    const midPoint = (asks[0].price + bids[0].price) / 2;\r\n\r\n    //\r\n    asks = setOrderBookInfo(asks, midPoint).slice(0, 21);\r\n    bids = setOrderBookInfo(bids, midPoint).slice(0, 21);\r\n\r\n    //\r\n    setMirrored(asks, bids);\r\n\r\n    // TODO: don't mutate state directly, though a dispatch will cause a re-render hence loop\r\n    state.book = { asks: [...asks], bids: [...bids] };\r\n\r\n    // to mirror hover\r\n    asks.reverse();\r\n\r\n    return (\r\n        <div className=\"order-book\">\r\n            <div className=\"order-book-list order-book-list--bids\">\r\n                <ul>\r\n                    {asks.map(item => {\r\n                        return (\r\n                            <OrderBookItem\r\n                                sender={EOrderBookSender.BookAsks}\r\n                                item={item}\r\n                                hover={state.hover}\r\n                            />\r\n                        );\r\n                    })}\r\n                </ul>\r\n            </div>\r\n            <div className=\"order-book-last-price\">{midPoint}</div>\r\n            <div className=\"order-book-list order-book-list--asks\">\r\n                <ul>\r\n                    {bids.map(item => {\r\n                        return (\r\n                            <OrderBookItem\r\n                                sender={EOrderBookSender.BookBids}\r\n                                item={item}\r\n                                hover={state.hover}\r\n                            />\r\n                        );\r\n                    })}\r\n                </ul>\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n", "import { Ref } from 'preact/hooks';\r\n\r\n// utils\r\nimport { getCanvasContext, lineY } from '@utils/canvas.utils';\r\nimport { getCssColor } from '@utils/color.utils';\r\nimport { getHoverOrderBook, getIplOrderBook } from '@utils/data.utils';\r\n\r\n// types\r\nimport { IOrderBookItem } from '../../OrderBook.types';\r\n\r\n/**\r\n *\r\n * @param ref\r\n * @param items non-interpolated items\r\n * @param moveY mouseY coordinate\r\n * @param hover interpolated hovered item of opposite axis\r\n * @param invert invert hover\r\n * @returns\r\n */\r\nexport const onDrawAxis = (\r\n    ref: Ref<HTMLCanvasElement>,\r\n    items: IOrderBookItem[],\r\n    moveY: number = 0,\r\n    hover: IOrderBookItem = {} as IOrderBookItem,\r\n    invert: boolean = false\r\n) => {\r\n    const {\r\n        canvas: { height, width },\r\n        ctx\r\n    } = getCanvasContext(ref);\r\n    ctx.clearRect(0, 0, width, height);\r\n\r\n    const clrLong = getCssColor('--clr-long');\r\n    const clrShort = getCssColor('--clr-short');\r\n    const clrLongBg50 = getCssColor('--clr-long-bg-50');\r\n    const clrShortBg50 = getCssColor('--clr-short-bg-50');\r\n    const clrRgbaBg50 = getCssColor('--clr-rgba-bg-50');\r\n\r\n    /**\r\n     * draw X lines with significant volumes\r\n     * @param ipl\r\n     * @param items\r\n     */\r\n    const drawSignificant = (\r\n        ipl: IOrderBookItem[],\r\n        items: IOrderBookItem[]\r\n    ) => {\r\n        ctx.beginPath();\r\n        ctx.setLineDash([2, 2]);\r\n\r\n        ctx.lineCap = 'round';\r\n        ctx.lineWidth = 1;\r\n\r\n        for (let i = 0; i < items.length; i++) {\r\n            if (!ipl[i].significant) continue;\r\n            const { totalVolume: x, totalPercent: y, long } = ipl[i];\r\n\r\n            // line (relative to direction 'long')\r\n            ctx.moveTo(0.5, y);\r\n            ctx.lineTo(long ? width - x : x, lineY(y));\r\n\r\n            ctx.strokeStyle = long ? clrLongBg50 : clrShortBg50;\r\n            ctx.stroke();\r\n\r\n            // hyphen\r\n\r\n            // text\r\n        }\r\n\r\n        ctx.stroke();\r\n        ctx.setLineDash([0, 0]);\r\n    };\r\n\r\n    /**\r\n     * draw 90* X/Y axis from mouse position\r\n     * @param items\r\n     * @returns\r\n     */\r\n    const drawAxis = (items: IOrderBookItem[]) => {\r\n        // interpolate items to fit canvas frame\r\n        const { ipl } = getIplOrderBook(height, width, items);\r\n\r\n        let iplHover = {} as IOrderBookItem;\r\n\r\n        // hover sent from state\r\n        if (Object.keys(hover).length) {\r\n            // opposite axis dispatched\r\n            if (invert) iplHover = ipl[ipl.length - 1 - hover.index];\r\n            else iplHover = ipl[hover.index];\r\n        }\r\n\r\n        // closest to our mouse position\r\n        if (!iplHover.index)\r\n            iplHover = getHoverOrderBook(moveY, ipl, items).iplHover;\r\n\r\n        // which direction\r\n        const { long } = items[0];\r\n\r\n        // height or 0 depending on direction\r\n        const thisX = width - iplHover.totalVolume;\r\n        const thisY = iplHover.totalPercent;\r\n\r\n        //\r\n        drawSignificant(ipl, items);\r\n\r\n        /**\r\n         * draw dashed lined relative to the mouse position\r\n         * @param x\r\n         * @param y\r\n         * @param long\r\n         */\r\n        const drawAxisLine = (x: number, y: number, long?: boolean) => {\r\n            ctx.beginPath();\r\n            ctx.setLineDash([2, 2]);\r\n\r\n            ctx.lineCap = 'round';\r\n            ctx.lineWidth = 1;\r\n            ctx.strokeStyle = long ? clrLong : clrShort;\r\n\r\n            // direction\r\n            x = long ? x : width - x;\r\n\r\n            // from current to mid-point\r\n            ctx.moveTo(x, y);\r\n            ctx.lineTo(x, long ? 0.5 : height);\r\n\r\n            // from current to left side\r\n            ctx.moveTo(x, y);\r\n            ctx.lineTo(0.5, y);\r\n\r\n            ctx.stroke();\r\n            ctx.setLineDash([0, 0]);\r\n        };\r\n        drawAxisLine(thisX, thisY, long);\r\n\r\n        /**\r\n         * draw circles at the dashed line connector\r\n         * @param x\r\n         * @param y\r\n         * @param long\r\n         */\r\n        const drawCircle = (x: number, y: number, long?: boolean) => {\r\n            ctx.beginPath();\r\n\r\n            // direction\r\n            x = long ? x : width - x;\r\n\r\n            ctx.lineWidth = 3;\r\n            ctx.fillStyle = long ? clrLong : clrShort;\r\n            ctx.arc(x, y, 3, 0, 2 * Math.PI);\r\n\r\n            ctx.fill();\r\n        };\r\n        drawCircle(thisX, thisY, long);\r\n\r\n        /**\r\n         * draw shaded box below or above\r\n         * @param x\r\n         * @param y\r\n         * @param long\r\n         */\r\n        const drawShade = (x: number, y: number, long?: boolean) => {\r\n            ctx.beginPath();\r\n\r\n            if (long) {\r\n                // move to sidebar\r\n                ctx.moveTo(width, y);\r\n                // bottom-right\r\n                ctx.lineTo(width, lineY(height));\r\n                // bottom-left\r\n                ctx.lineTo(0, lineY(height));\r\n                // up to key\r\n                ctx.lineTo(0, y);\r\n            } else {\r\n                // move to sidebar\r\n                ctx.moveTo(width, y);\r\n                // top-right\r\n                ctx.lineTo(width, 0);\r\n                // top-left\r\n                ctx.lineTo(0, 0);\r\n                // down to key\r\n                ctx.lineTo(0, y);\r\n            }\r\n\r\n            ctx.fillStyle = clrRgbaBg50;\r\n            ctx.fill();\r\n        };\r\n        drawShade(thisX, thisY, long);\r\n\r\n        // return hovered 'item'\r\n        // TODO: return mirrored if 'long'\r\n\r\n        return iplHover;\r\n    };\r\n\r\n    return drawAxis(items);\r\n};\r\n", "import { h } from 'preact';\r\nimport { useEffect, useMemo, useRef } from 'preact/hooks';\r\n\r\n// components\r\nimport { Canvas } from '@components/Canvas/Canvas';\r\nimport { ICanvasEvents } from '@components/Canvas/Canvas.types';\r\nimport { onDrawAxis } from './onDrawAxis';\r\n\r\n// utils\r\nimport { getCanvasContext, getCanvasPos } from '@utils/canvas.utils';\r\n\r\n// actions\r\nimport { useOrderBook } from '../../OrderBook.store';\r\n\r\n// types\r\nimport {\r\n    EOrderBookAction,\r\n    EOrderBookSender,\r\n    IOrderBookItem\r\n} from '../../OrderBook.types';\r\n\r\n// styles\r\nimport './Axis.module.scss';\r\n\r\nexport interface IAxisGraphProps {\r\n    long: boolean;\r\n}\r\n\r\nexport const AxisGraph = ({ long }: IAxisGraphProps) => {\r\n    const { state, dispatch } = useOrderBook();\r\n\r\n    const ref = useRef({} as HTMLCanvasElement);\r\n    const items = long ? state.book.bids : state.book.asks;\r\n    const context = long\r\n        ? EOrderBookSender.GraphAsks\r\n        : EOrderBookSender.GraphBids;\r\n\r\n    // TODO: this is fired twice by each sender, a total of 4\r\n\r\n    // run on 'state' change\r\n    useEffect(() => {\r\n        // this 'context' didn't trigger state change\r\n        if (state.sender !== context) {\r\n            // hover should be mirrored as 'hover' is not from this axis\r\n            if (state.hover.long !== long) {\r\n                onDrawAxis(ref, items, 0, state.hover, true);\r\n            }\r\n\r\n            // hover should not be mirrored as 'hover' is from this axis\r\n            else if (state.hover.long == long) {\r\n                onDrawAxis(ref, items, 0, state.hover, false);\r\n            }\r\n        }\r\n    }, [state.hover]);\r\n\r\n    const events: ICanvasEvents = {\r\n        onLoad: function () {\r\n            onDrawAxis(ref, items);\r\n        },\r\n        onMouseMove: function (e: MouseEvent) {\r\n            const { canvas } = getCanvasContext(ref);\r\n            const { y } = getCanvasPos(canvas, e);\r\n\r\n            // highlight in axis\r\n            const hover = onDrawAxis(ref, items, y);\r\n\r\n            // dispatch our 'hover' to orderbook and to opposite axis\r\n            dispatch({\r\n                cmd: EOrderBookAction.HoverEntry,\r\n                sender: context,\r\n                hover\r\n            });\r\n        }\r\n    };\r\n\r\n    // pure event handler\r\n    const eventsMemo = useMemo(() => events, []);\r\n\r\n    return (\r\n        <Canvas\r\n            id=\"depth-axis\"\r\n            height={400}\r\n            width={200}\r\n            canvasRef={ref}\r\n            events={eventsMemo}\r\n        />\r\n    );\r\n};\r\n", "import { Ref } from 'preact/hooks';\r\n\r\n// utils\r\nimport { getCanvasContext } from '@utils/canvas.utils';\r\nimport { getCssColor } from '@utils/color.utils';\r\nimport { getHoverOrderBook, getIplOrderBook } from '@utils/data.utils';\r\n\r\n// types\r\nimport { IOrderBookItem } from '../../OrderBook.types';\r\n\r\nexport const onDrawDepth = (\r\n    ref: Ref<HTMLCanvasElement>,\r\n    items: IOrderBookItem[],\r\n    moveX: number = 0\r\n) => {\r\n    let {\r\n        canvas: { height, width },\r\n        ctx\r\n    } = getCanvasContext(ref);\r\n\r\n    ctx.clearRect(0, 0, width, height);\r\n\r\n    const clrShort = getCssColor('--clr-short');\r\n    const clrLong = getCssColor('--clr-long');\r\n    const clrShortBg20 = getCssColor('--clr-short-bg-20');\r\n    const clrLongBg20 = getCssColor('--clr-long-bg-20');\r\n\r\n    // TODO: adjust coordinates to fit on 'upper' or 'lower' axis\r\n    const drawDepth = (items: IOrderBookItem[]) => {\r\n        // interpolate items to fit canvas frame\r\n        const { ipl } = getIplOrderBook(height, width, items);\r\n        const { iplHover } = getHoverOrderBook(moveX, ipl, items);\r\n\r\n        //\r\n        const { long } = items[0];\r\n\r\n        //\r\n        for (let i = 0; i < ipl.length; i++) {\r\n            // unknown destination on first iteration\r\n            if (i == 0) continue;\r\n\r\n            // assign\r\n            const last = ipl[i - 1];\r\n            const next = ipl[i];\r\n\r\n            let lastX = last.totalVolume;\r\n            let nextX = next.totalVolume;\r\n\r\n            let lastY = last.totalPercent;\r\n            let nextY = next.totalPercent;\r\n\r\n            // if 'long' we need to climb in opposite direction\r\n            if (long) {\r\n                lastX = width - lastX;\r\n                nextX = width - nextX;\r\n            }\r\n\r\n            // start\r\n            ctx.beginPath();\r\n            ctx.lineCap = 'round';\r\n\r\n            // move to x0 (amount), y0 (% in price change)\r\n            ctx.moveTo(lastX, lastY);\r\n            // step out to (x1, y0)\r\n            ctx.lineTo(nextX, lastY);\r\n            // draw to (x1, y1)\r\n            ctx.lineTo(nextX, nextY);\r\n\r\n            // draw\r\n            ctx.lineWidth = 1;\r\n            ctx.strokeStyle = long ? clrLong : clrShort;\r\n            ctx.stroke();\r\n\r\n            // stroke behind composite\r\n            ctx.globalCompositeOperation = 'destination-over';\r\n\r\n            // draw to end to prepare for fill\r\n            long\r\n                ? ctx.lineTo(height, height) // or (0, 0)\r\n                : ctx.lineTo(height, 0); // or (0, height)\r\n\r\n            // stroke to remove our filled edges; to visualize, change strokeStyle\r\n            ctx.fillStyle = long ? clrLongBg20 : clrShortBg20;\r\n            ctx.strokeStyle = ctx.fillStyle;\r\n            ctx.stroke();\r\n\r\n            // fill the space between each line\r\n            ctx.fill();\r\n\r\n            // back to front of composite\r\n            ctx.globalCompositeOperation = 'source-over';\r\n\r\n            // done with line\r\n            ctx.closePath();\r\n        }\r\n\r\n        // return item hovered\r\n        return iplHover;\r\n    };\r\n\r\n    return drawDepth(items);\r\n};\r\n", "import { h } from 'preact';\r\nimport { useMemo, useRef } from 'preact/hooks';\r\n\r\n// components\r\nimport { Canvas } from '@components/Canvas/Canvas';\r\nimport { ICanvasEvents } from '@components/Canvas/Canvas.types';\r\nimport { onDrawDepth } from './onDrawDepth';\r\n\r\n// utils\r\nimport { getCanvasContext, getCanvasPos } from '@utils/canvas.utils';\r\n\r\n// types\r\nimport { useOrderBook } from '../../OrderBook.store';\r\nimport {\r\n    EOrderBookAction,\r\n    EOrderBookSender,\r\n    IOrderBookItem\r\n} from '../../OrderBook.types';\r\n\r\nexport interface IDepthGraphProps {\r\n    long: boolean;\r\n}\r\n\r\nexport const DepthGraph = ({ long }: IDepthGraphProps) => {\r\n    // listen to orderbook and new data to re-render\r\n    const {\r\n        state: { book },\r\n        dispatch\r\n    } = useOrderBook();\r\n\r\n    const ref = useRef({} as HTMLCanvasElement);\r\n\r\n    const items = long ? book.bids : book.asks;\r\n    const sender = long\r\n        ? EOrderBookSender.GraphAsks\r\n        : EOrderBookSender.GraphBids;\r\n\r\n    const events: ICanvasEvents = {\r\n        onLoad: function () {\r\n            onDrawDepth(ref, items);\r\n        },\r\n        onMouseMove: function (e: MouseEvent) {\r\n            const { canvas } = getCanvasContext(ref);\r\n            const { x } = getCanvasPos(canvas, e);\r\n\r\n            const hover = onDrawDepth(ref, items, x);\r\n\r\n            dispatch({\r\n                cmd: EOrderBookAction.HoverEntry,\r\n                sender,\r\n                hover\r\n            });\r\n        }\r\n    };\r\n\r\n    // pure event handler\r\n    const eventsMemo = useMemo(() => events, []);\r\n\r\n    return (\r\n        <Canvas\r\n            id=\"depth-graph\"\r\n            height={400}\r\n            width={200}\r\n            canvasRef={ref}\r\n            events={eventsMemo}\r\n        />\r\n    );\r\n};\r\n", "import { IOrderBookItem } from '@components/OrderBook/OrderBook.types';\r\n\r\n/**\r\n * format 'raw' orderbook data\r\n * @param items\r\n * @param long\r\n * @returns\r\n */\r\nexport const getOrderBookFormatted = (items: string[][], long?: boolean) => {\r\n    return items.map(item => {\r\n        const toNum = item.map(k => Number(k));\r\n        const [price, volume] = toNum;\r\n\r\n        return { price, volume, long } as IOrderBookItem;\r\n    }) as IOrderBookItem[];\r\n};\r\n", "export default {\r\n    lastUpdateId: 14730815480,\r\n    bids: [\r\n        ['62054.41000000', '0.02967000'],\r\n        ['62052.42000000', '0.01000000'],\r\n        ['62050.11000000', '0.00400000'],\r\n        ['62048.40000000', '0.10057000'],\r\n        ['62048.20000000', '0.18750000'],\r\n        ['62048.15000000', '0.06735000'],\r\n        ['62046.65000000', '0.02000000'],\r\n        ['62046.54000000', '0.00161000'],\r\n        ['62043.56000000', '0.04000000'],\r\n        ['62043.52000000', '0.00032000'],\r\n        ['62043.21000000', '0.04027000'],\r\n        ['62042.37000000', '0.09786000'],\r\n        ['62041.72000000', '0.18750000'],\r\n        ['62041.29000000', '0.23000000'],\r\n        ['62040.65000000', '0.00806000'],\r\n        ['62040.44000000', '0.00032000'],\r\n        ['62040.01000000', '0.06284000'],\r\n        ['62039.54000000', '0.00514000'],\r\n        ['62038.48000000', '0.03000000'],\r\n        ['62037.77000000', '0.05000000'],\r\n        ['62037.36000000', '0.00032000'],\r\n        ['62035.35000000', '0.08053000'],\r\n        ['62034.72000000', '0.51058000'],\r\n        ['62034.28000000', '0.00032000'],\r\n        ['62034.12000000', '0.18750000'],\r\n        ['62032.87000000', '0.03222000'],\r\n        ['62032.15000000', '0.00298000'],\r\n        ['62032.05000000', '0.01829000'],\r\n        ['62031.20000000', '0.00032000'],\r\n        ['62030.35000000', '0.05000000'],\r\n        ['62030.19000000', '0.01318000'],\r\n        ['62029.37000000', '0.21639000'],\r\n        ['62029.13000000', '0.10000000'],\r\n        ['62028.33000000', '0.30810000'],\r\n        ['62028.19000000', '0.18530000'],\r\n        ['62028.12000000', '0.00032000'],\r\n        ['62026.44000000', '0.03130000'],\r\n        ['62025.38000000', '0.23558000'],\r\n        ['62025.37000000', '0.08203000'],\r\n        ['62025.04000000', '0.00032000'],\r\n        ['62024.42000000', '0.18750000'],\r\n        ['62023.51000000', '0.20000000'],\r\n        ['62023.35000000', '0.01000000'],\r\n        ['62022.93000000', '0.10000000'],\r\n        ['62021.96000000', '0.00032000'],\r\n        ['62019.74000000', '0.00295000'],\r\n        ['62018.88000000', '0.00032000'],\r\n        ['62018.21000000', '0.18750000'],\r\n        ['62015.80000000', '0.00032000'],\r\n        ['62014.04000000', '0.00413000'],\r\n        ['62013.41000000', '0.24677000'],\r\n        ['62013.40000000', '0.57941000'],\r\n        ['62012.72000000', '0.00032000'],\r\n        ['62012.53000000', '0.00441000'],\r\n        ['62012.43000000', '0.12081000'],\r\n        ['62011.72000000', '0.20217000'],\r\n        ['62011.46000000', '0.06287000'],\r\n        ['62011.34000000', '0.03439000'],\r\n        ['62011.33000000', '0.18750000'],\r\n        ['62011.20000000', '0.02155000'],\r\n        ['62011.14000000', '0.20000000'],\r\n        ['62011.08000000', '0.04000000'],\r\n        ['62009.64000000', '0.00032000'],\r\n        ['62009.15000000', '0.06287000'],\r\n        ['62008.83000000', '0.40000000'],\r\n        ['62006.57000000', '0.56014000'],\r\n        ['62006.56000000', '1.60032000'],\r\n        ['62006.25000000', '0.04794000'],\r\n        ['62003.48000000', '0.00032000'],\r\n        ['62002.97000000', '0.20000000'],\r\n        ['62002.93000000', '0.18750000'],\r\n        ['62002.54000000', '0.01516000'],\r\n        ['62000.40000000', '0.00032000'],\r\n        ['62000.02000000', '0.26807000'],\r\n        ['62000.01000000', '0.00907000'],\r\n        ['62000.00000000', '0.00090000'],\r\n        ['61999.59000000', '0.57369000'],\r\n        ['61999.57000000', '0.02000000'],\r\n        ['61999.53000000', '0.00100000'],\r\n        ['61999.40000000', '0.16107000'],\r\n        ['61998.54000000', '0.94700000'],\r\n        ['61997.32000000', '0.00032000'],\r\n        ['61995.75000000', '0.00076000'],\r\n        ['61995.54000000', '0.03322000'],\r\n        ['61994.31000000', '0.00413000'],\r\n        ['61994.24000000', '0.00032000'],\r\n        ['61993.79000000', '0.91851000'],\r\n        ['61993.78000000', '0.18750000'],\r\n        ['61992.91000000', '0.02300000'],\r\n        ['61991.16000000', '0.00032000'],\r\n        ['61990.38000000', '2.85000000'],\r\n        ['61989.59000000', '0.00464000'],\r\n        ['61988.08000000', '0.00032000'],\r\n        ['61985.65000000', '0.04840000'],\r\n        ['61985.61000000', '0.25223000'],\r\n        ['61985.60000000', '0.18750000'],\r\n        ['61985.00000000', '0.00032000'],\r\n        ['61984.19000000', '0.69499000'],\r\n        ['61983.79000000', '0.00413000'],\r\n        ['61982.79000000', '0.03150000']\r\n    ],\r\n    asks: [\r\n        ['62054.42000000', '0.21685000'],\r\n        ['62054.86000000', '0.01379000'],\r\n        ['62057.49000000', '0.14000000'],\r\n        ['62059.03000000', '0.07169000'],\r\n        ['62059.04000000', '0.18000000'],\r\n        ['62060.00000000', '0.10517000'],\r\n        ['62061.21000000', '0.00150000'],\r\n        ['62063.70000000', '0.18750000'],\r\n        ['62065.53000000', '0.00464000'],\r\n        ['62065.84000000', '0.02000000'],\r\n        ['62066.00000000', '0.01000000'],\r\n        ['62066.27000000', '0.02716000'],\r\n        ['62067.99000000', '0.14209000'],\r\n        ['62068.00000000', '0.40538000'],\r\n        ['62068.79000000', '0.00033000'],\r\n        ['62069.06000000', '0.16090000'],\r\n        ['62069.17000000', '0.06284000'],\r\n        ['62069.18000000', '0.00026000'],\r\n        ['62070.00000000', '0.01000000'],\r\n        ['62070.21000000', '0.18750000'],\r\n        ['62070.73000000', '0.02000000'],\r\n        ['62070.86000000', '0.01000000'],\r\n        ['62071.17000000', '0.06287000'],\r\n        ['62071.24000000', '0.00032000'],\r\n        ['62071.99000000', '0.20030000'],\r\n        ['62072.00000000', '0.04000000'],\r\n        ['62072.74000000', '0.24389000'],\r\n        ['62072.78000000', '0.02000000'],\r\n        ['62072.88000000', '0.02000000'],\r\n        ['62072.99000000', '0.22729000'],\r\n        ['62073.00000000', '0.02100000'],\r\n        ['62073.28000000', '0.41063000'],\r\n        ['62073.29000000', '0.57942000'],\r\n        ['62073.85000000', '0.00574000'],\r\n        ['62073.86000000', '0.20000000'],\r\n        ['62073.95000000', '0.20000000'],\r\n        ['62074.32000000', '0.00032000'],\r\n        ['62075.00000000', '0.00080000'],\r\n        ['62075.32000000', '0.00300000'],\r\n        ['62075.47000000', '0.00161000'],\r\n        ['62075.48000000', '0.18532000'],\r\n        ['62075.74000000', '0.00876000'],\r\n        ['62076.14000000', '0.00032000'],\r\n        ['62076.30000000', '0.00322000'],\r\n        ['62077.04000000', '0.03000000'],\r\n        ['62077.10000000', '0.46920000'],\r\n        ['62077.11000000', '0.97814000'],\r\n        ['62077.40000000', '0.00032000'],\r\n        ['62077.85000000', '0.01095000'],\r\n        ['62077.86000000', '0.32693000'],\r\n        ['62077.87000000', '0.00405000'],\r\n        ['62078.89000000', '0.37225000'],\r\n        ['62078.90000000', '0.28123000'],\r\n        ['62079.00000000', '0.04000000'],\r\n        ['62079.21000000', '0.20000000'],\r\n        ['62079.22000000', '0.09765000'],\r\n        ['62079.38000000', '0.25711000'],\r\n        ['62080.07000000', '0.18750000'],\r\n        ['62080.37000000', '0.08053000'],\r\n        ['62080.48000000', '0.00032000'],\r\n        ['62080.83000000', '0.00026000'],\r\n        ['62081.00000000', '0.03000000'],\r\n        ['62081.30000000', '0.22250000'],\r\n        ['62081.53000000', '0.42496000'],\r\n        ['62081.54000000', '0.01988000'],\r\n        ['62081.89000000', '0.98379000'],\r\n        ['62081.90000000', '0.00050000'],\r\n        ['62082.01000000', '0.01000000'],\r\n        ['62082.71000000', '0.20000000'],\r\n        ['62083.31000000', '0.15000000'],\r\n        ['62083.56000000', '0.00032000'],\r\n        ['62085.40000000', '0.00027000'],\r\n        ['62085.42000000', '0.10000000'],\r\n        ['62085.94000000', '0.06620000'],\r\n        ['62086.09000000', '0.70300000'],\r\n        ['62086.26000000', '0.08520000'],\r\n        ['62086.55000000', '0.05787000'],\r\n        ['62086.64000000', '0.00032000'],\r\n        ['62086.94000000', '1.56200000'],\r\n        ['62086.95000000', '0.00017000'],\r\n        ['62087.54000000', '0.00056000'],\r\n        ['62087.60000000', '0.25000000'],\r\n        ['62087.92000000', '0.92687000'],\r\n        ['62087.93000000', '0.18750000'],\r\n        ['62088.00000000', '0.00032000'],\r\n        ['62088.86000000', '0.00242000'],\r\n        ['62088.89000000', '0.07500000'],\r\n        ['62089.72000000', '0.00032000'],\r\n        ['62089.99000000', '0.07035000'],\r\n        ['62090.00000000', '0.84727000'],\r\n        ['62090.48000000', '0.06967000'],\r\n        ['62091.74000000', '0.00363000'],\r\n        ['62091.99000000', '0.09009000'],\r\n        ['62092.19000000', '0.20000000'],\r\n        ['62092.79000000', '0.12930000'],\r\n        ['62092.80000000', '0.00032000'],\r\n        ['62093.17000000', '0.02300000'],\r\n        ['62093.65000000', '0.11224000'],\r\n        ['62094.18000000', '0.05000000'],\r\n        ['62094.79000000', '0.09511000']\r\n    ]\r\n};\r\n", "export enum EMarketKey {\r\n    BTC = 'BTC',\r\n    ETH = 'ETH'\r\n}\r\n\r\nexport interface IMarketSpark {\r\n    open: number;\r\n    high: number;\r\n    low: number;\r\n    close: number;\r\n}\r\n\r\nexport interface IMarketItem {\r\n    index: number;\r\n    openTime: number;\r\n    volume: number;\r\n    spark: IMarketSpark;\r\n}\r\n\r\nexport interface IMarketState {\r\n    key: EMarketKey;\r\n    name: string;\r\n    rank: number;\r\n    items: IMarketItem[];\r\n}\r\n\r\nexport interface IMockOrderBook {\r\n    lastUpdateId: number;\r\n    bids: string[][];\r\n    asks: string[][];\r\n}\r\n", "import { getOrderBookFormatted } from './mock.utils';\r\n\r\nimport btcBook from './binance-btcusdt-book';\r\nimport { IOrderBook } from '@components/OrderBook/OrderBook.types';\r\nimport { EMarketKey, IMockOrderBook } from 'src/types/data.types';\r\n\r\n/**\r\n * https://api.binance.com/api/v3/depth?symbol=BTCUSDT\r\n */\r\nexport const getMockOrderBook = (key: EMarketKey) => {\r\n    const json = key == EMarketKey.BTC ? btcBook : btcBook;\r\n    const { asks, bids }: IMockOrderBook = json;\r\n\r\n    return {\r\n        asks: getOrderBookFormatted(asks, false),\r\n        bids: getOrderBookFormatted(bids, true)\r\n    } as IOrderBook;\r\n};\r\n", "/**\r\n * send POST request\r\n * @param body\r\n * @param headers\r\n * @returns\r\n */\r\nexport const httpPost = async <T>(\r\n    url: string,\r\n    body: Object,\r\n    headers?: Headers\r\n) => {\r\n    const res = await fetch(url, {\r\n        method: 'POST',\r\n        headers: Object.assign(\r\n            { 'content-type': 'application/json' },\r\n            headers || {}\r\n        ),\r\n        body: JSON.stringify(body)\r\n    });\r\n\r\n    return (await res.json()) as T;\r\n};\r\n", "import { httpPost } from '@utils/http.utils';\r\nimport { IGqlRequest, IGqlResponse, TGraphCmd } from './gql.types';\r\n\r\nexport abstract class GqlApi {\r\n    /**\r\n     * is $var object\r\n     */\r\n    protected isObject(v: unknown): boolean {\r\n        return (\r\n            typeof v == 'object' &&\r\n            !(v instanceof Date) &&\r\n            !Array.isArray(v) &&\r\n            !(v instanceof RegExp)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * map each #var in SDL\r\n     * @param query\r\n     * @param vars\r\n     */\r\n    protected process(query: string, vars: Record<string, any>): string {\r\n        for (const k of Object.keys(vars || {})) {\r\n            if (!vars || !vars[k]) continue;\r\n\r\n            // resolve nested objects recursively\r\n            if (this.isObject(vars[k])) {\r\n                return this.process(query, vars[k]);\r\n            }\r\n\r\n            // map #var to value\r\n            const v = vars[k];\r\n            query = query.replace('#' + k, typeof v == 'string' ? `\"${v}\"` : v);\r\n        }\r\n\r\n        return query;\r\n    }\r\n\r\n    /**\r\n     * pre-process SDL input before sending to HTTP\r\n     * @param query SDL string\r\n     * @param vars #var mapping as object\r\n     */\r\n    protected async request<T, TR>(query: string, vars?: T) {\r\n        query = this.process(query, vars || {});\r\n        query = query.replace(/[\\s\\n]+/g, ' ');\r\n\r\n        const req = {\r\n            query\r\n        } as IGqlRequest<T>;\r\n\r\n        return await httpPost<IGqlResponse<TR>>(\r\n            'https://api.thegraph.com/subgraphs/name/ianlapham/uniswap-v3-subgraph',\r\n            req\r\n        );\r\n    }\r\n}\r\n", "import { EMarketKey, IMarketItem, IMarketState } from 'src/types/data.types';\r\nimport { IQueryTokenHourOhlcRes } from './queries/query-token-hour-ohlc';\r\n\r\nexport const getMarketDataFormatted = (res: IQueryTokenHourOhlcRes) => {\r\n    const items = [] as IMarketItem[];\r\n\r\n    res.tokenHourDatas.forEach((entry, index) => {\r\n        const { open, high, low, close } = entry;\r\n\r\n        const item = {\r\n            index,\r\n            openTime: entry.periodStartUnix * 1000,\r\n            volume: Number(entry.totalValueLocked),\r\n            spark: {\r\n                open: Number(open),\r\n                high: Number(high),\r\n                low: Number(low),\r\n                close: Number(close)\r\n            }\r\n        } as IMarketItem;\r\n\r\n        items.push(item);\r\n    });\r\n\r\n    return items;\r\n};\r\n\r\nexport const getStateFromAddress = (address: string) => {\r\n    switch (address) {\r\n        case '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599':\r\n            return {\r\n                key: EMarketKey.BTC,\r\n                name: 'Bitcoin',\r\n                rank: 1,\r\n                items: {} as IMarketItem[]\r\n            } as IMarketState;\r\n\r\n        case '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2':\r\n            return {\r\n                key: EMarketKey.ETH,\r\n                name: 'Ethereum',\r\n                rank: 2,\r\n                items: {} as IMarketItem[]\r\n            } as IMarketState;\r\n    }\r\n\r\n    return {} as IMarketState;\r\n};\r\n", "import { EMarketKey, IMarketState } from 'src/types/data.types';\r\nimport { GqlApi } from './gql.api';\r\nimport { getMarketDataFormatted, getStateFromAddress } from './gql.utils';\r\nimport {\r\n    IQueryTokenHourOhlcReq,\r\n    IQueryTokenHourOhlcRes\r\n} from './queries/query-token-hour-ohlc';\r\n\r\nexport class GqlQuery extends GqlApi {\r\n    public async getTokenHourlyOHLC(vars: IQueryTokenHourOhlcReq) {\r\n        const query =\r\n            // TODO: make one line of this\r\n            `\r\n        {\r\n            tokenHourDatas(\r\n              first: 100\r\n              skip: 0\r\n              where: {\r\n                  token: #token, \r\n                  periodStartUnix_gt: #start\r\n              }    \r\n              orderBy: periodStartUnix\r\n              orderDirection: asc\r\n          ) { \r\n              periodStartUnix\r\n              high\r\n              low\r\n              open\r\n              close\r\n              totalValueLocked\r\n          }  \r\n        }`;\r\n\r\n        //\r\n        const res = await this.request<\r\n            IQueryTokenHourOhlcReq,\r\n            IQueryTokenHourOhlcRes\r\n        >(query, vars);\r\n\r\n        //\r\n        const state = getStateFromAddress(vars.token);\r\n        state.items = getMarketDataFormatted(res.data);\r\n\r\n        return state;\r\n    }\r\n}\r\n", "import { h } from 'preact';\r\nimport { useEffect, useState } from 'preact/hooks';\r\n\r\n// components\r\nimport { MarketBox } from '@components/MarketBox/MarketBox';\r\nimport { MarketChart } from '@components/MarketGraph/MarketGraph';\r\nimport { OrderBook } from '@components/OrderBook/OrderBook';\r\nimport {\r\n    OrderBookStore,\r\n    useOrderBook\r\n} from '@components/OrderBook/OrderBook.store';\r\nimport { AxisGraph } from '@components/OrderBook/graphs/axis/AxisGraph';\r\nimport { DepthGraph } from '@components/OrderBook/graphs/depth/DepthGraph';\r\n\r\n// data\r\nimport { getMockOrderBook } from 'src/mock';\r\nimport { GqlQuery } from '@api/gql.query';\r\n\r\n// types\r\nimport { IOrderBook } from '@components/OrderBook/OrderBook.types';\r\nimport { EMarketKey, IMarketState } from 'src/types/data.types';\r\n\r\n// styles\r\nimport './MainView.module.scss';\r\n\r\nexport const MainView = () => {\r\n    const [marketState, useMarketStates] = useState(\r\n        {} as Record<EMarketKey, IMarketState>\r\n    );\r\n\r\n    const [bookState, useBookStates] = useState(\r\n        {} as Record<EMarketKey, IOrderBook>\r\n    );\r\n\r\n    const onLoadOrderBookData = async () => {\r\n        const state: Record<EMarketKey, IOrderBook> = {\r\n            [EMarketKey.BTC]: await getMockOrderBook(EMarketKey.BTC),\r\n            [EMarketKey.ETH]: await getMockOrderBook(EMarketKey.ETH)\r\n        };\r\n        useBookStates(state);\r\n    };\r\n\r\n    const onQueryLocalStorage = async (\r\n        address: string,\r\n        name: string,\r\n        start: number\r\n    ) => {\r\n        const query = new GqlQuery();\r\n        const key = `market-data-${name}`;\r\n\r\n        if (!localStorage.hasOwnProperty(key)) {\r\n            const data = await query.getTokenHourlyOHLC({\r\n                token: address,\r\n                start\r\n            });\r\n            localStorage.setItem(key, JSON.stringify(data));\r\n        }\r\n\r\n        return JSON.parse(localStorage.getItem(key) as string);\r\n    };\r\n\r\n    const onQueryTokenData = async () => {\r\n        // 4 days\r\n        const start = Math.round(\r\n            (new Date().getTime() - 24 * 4 * 60 * 60 * 1000) / 1000\r\n        );\r\n\r\n        const state: Record<EMarketKey, IMarketState> = {\r\n            [EMarketKey.BTC]: await onQueryLocalStorage(\r\n                '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599',\r\n                'btc',\r\n                start\r\n            ),\r\n            [EMarketKey.ETH]: await onQueryLocalStorage(\r\n                '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\r\n                'eth',\r\n                start\r\n            )\r\n        };\r\n        useMarketStates(state);\r\n    };\r\n\r\n    // on mount\r\n    useEffect(() => {\r\n        // onLoadMarketData();\r\n        onLoadOrderBookData();\r\n        onQueryTokenData();\r\n    }, []);\r\n\r\n    // loading\r\n    if (!Object.keys(marketState).length) {\r\n        return <div>Loading...</div>;\r\n    }\r\n\r\n    return (\r\n        <div>\r\n            <div className=\"orderbook-component\">\r\n                <OrderBookStore>\r\n                    <OrderBook\r\n                        asks={bookState.BTC.asks}\r\n                        bids={bookState.BTC.bids}\r\n                    />\r\n                    <div className=\"depth-chart-grid\">\r\n                        <div className=\"depth-combo\">\r\n                            <DepthGraph long={false} />\r\n                            <AxisGraph long={false} />\r\n                        </div>\r\n                        <div className=\"depth-combo\">\r\n                            <DepthGraph long={true} />\r\n                            <AxisGraph long={true} />\r\n                        </div>\r\n                    </div>\r\n                </OrderBookStore>\r\n            </div>\r\n\r\n            <div className=\"market-box-grid\">\r\n                <MarketBox state={marketState.BTC} />\r\n                <MarketBox state={marketState.ETH} />\r\n            </div>\r\n            <MarketChart items={marketState.BTC.items} />\r\n        </div>\r\n    );\r\n};\r\n", "import { h, render } from 'preact';\r\nimport Router, { Route } from 'preact-router';\r\nimport { MainView } from './views/MainView';\r\n\r\nexport const Main = () => (\r\n    <Router>\r\n        <Route default component={MainView} />\r\n    </Router>\r\n);\r\n\r\nrender(<MainView />, document.getElementById('app') as HTMLElement);\r\n"],
  "mappings": "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CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA;AAAA,IAEvB,MAAM;AAAA,MACF,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAAA,MACnB,CAAC,kBAAkB;AAA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",
  "names": []
}
